---
layout: post
title: "《深度探索C++对象模型》读书笔记"
date: 2026-1-20
categories: 
excerpt: 简单记录一下读这本书的一些心得
author: Tizeng
---

* content
{:toc}

这本书毕业时就有耳闻，买来之后发现以当时的水平根本看不下去，现在陆续把基本c++有关的书都读了之后，是时候补一下这本书了。
购于2019.2.28

## 与C的关系

第一章提到c++为了与c兼容费了不少劲，如class和struct，二者在底层被视为同类，除了访问级别的区别，更多的是我们想要一个什么样的数据结构。

C中一些对struct的操作到了c++可能会失效。如在struct的末尾声明一个单元素的数组，在分配内存的时候可以按需多分配任意那个数组类型大小的内存，达到“柔性数组”的目的。
其原理是利用了c允许访问超出数组大小的元素，而在struct末尾多分配的内存保证是连续的，因此我们可以按自己的需要去分配和访问。
但到了c++情况就不同了，因为class内存的布局和public、protect、private的位置有关，只有在同一个acess section内的成员，才保证其在内存中按顺序分布，不同的section中的成员是不确定的。

## 默认构造

没有任何参数，或所有参数都有默认值的构造称为默认构造。
第二章提到编译器只在自己需要的时候为class生成默认构造，但并不会帮用户初始化成员变量，除非是class类型且也存在默认构造的成员。
一共有4中情况编译器会生成，具体的就不列出了，重点是是否为编译器所需，比如自身或基类包含虚函数的类，需要一个vptr来指向vtbl，那么这个vptr的初始化就需要有地方去完成（在所有的构造函数中）。
如果用户未定义任何构造函数，编译器就会生成一个默认构造来做这些事。
除此之外编译器并不会为我们合成，因为并不需要。

## 拷贝构造

2.2一直在讨论编译器什么时候不会执行bitwise copy，换句话说只要条件允许，编译器便会去执行类似`memcpy`的操作，因为这样效率最高。
与默认构造类似，拷贝构造会在编译器需要的时候生成，如需在子类对象赋值给基类对象时，需要保证基类的vptr仍然指向基类的vtbl而不是子类的。
类似这样的情况便不能进行bitwise copy。
需要注意的是，要进行bitwise copy，条件是拷贝构造必须为trivial，也就是说必须由编译器判断当前没有额外的事情需要处理，且用户也没有定义拷贝构造时。
只要用户定义了拷贝构造，就会被视为nontrivial，除非让它` = default`。
