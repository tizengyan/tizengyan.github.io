---
layout: post
title:  "C++面向对象基础"
date:   2019-02-18 13:22:54
categories: 基础知识
tags: OOP
excerpt: C++面向对象编程基础
author: Tizeng
---

* content
{:toc}

## 1.结构体和类

`struct`和`class`本质上只有两点区别：

* 默认继承权限不同。
    `class`的继承如果不做指定，默认为`private`继承，而`struct`中默认为`public`继承。

* 成员的默认访问权限不同。
    `class`中的成员变量和成员函数默认权限是`private`，而`struct`中默认权限是`public`。

## 2.构造函数

类的构造函数是一种特殊的成员函数，它会在每次创建类的新对象时执行。构造函数的名称与类的名称必须完全相同，并且不会返回任何类型，也不会返回`void`。构造函数可用于为某些成员变量设置初始值。**析构函数**和构造函数对应，只是在定义时在函数明前加`~`关键字，用于在程序结束时释放内存等。

在构造函数之前加上`explicit`关键字，可以禁止隐式转换。

### 带参数的构造函数

构造函数可以在定义时根据需要加入若干参数，用于对成员变量初始化。假设有一个类A，其中有X、Y、Z三个成员变量（字段），我们可以通过以下初始化列表来简化构造函数：

```c++
A::A( double a, double b, double c): X(a), Y(b), Z(c){}
```

## 3.拷贝构造函数

拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。以下情况会调用拷贝构造函数：

* 一个对象需要通过另外一个对象进行初始化

    比如用`=`进行赋值

* 一个对象以值传递的方式传入函数体

    此时传入函数的对象会调用拷贝构造函数生成一个新的对象，并在函数执行完毕后析构掉它

* 一个对象以值传递的方式从函数返回

也就是说当该类型的对象传递给函数或从函数返回该类型的对象时，将隐式调用拷贝构造函数。

如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。拷贝构造函数的最常见形式如下：

```c++
classname (const classname &obj) {
   // 构造函数的主体
}
```

## 4.友元函数（friend function）

类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。

友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。

如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字`friend`，如下所示：

```c++
class Box{
   double width;
public:
   double length;
   friend void printWidth( Box box );
   void setWidth( double wid );
};
```

声明类`ClassTwo`的所有成员函数作为类`ClassOne`的友元，需要在类`ClassOne`的定义中放置如下声明：

```c++
friend class ClassTwo;
```

注意友元函数没有`this`指针，因为友元不是类的成员，只有成员函数才有`this`指针。

派生类的友元函数可以访问从基类继承来的所有成员，但是对于基类来说，它并不是友元函数。

## 5.内联函数（inline function）

C++ 内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。

* 在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符

* 在内联函数内不允许使用循环语句和开关语句

* 内联函数的定义必须出现在内联函数第一次调用之前

* 类结构中所在的类说明内部定义的函数是内联函数

* 尽量当函数只有10行甚至更少时才将其定义为内联函数

## 6.类的静态成员（static）

首先介绍普通函数中的静态变量：

> When a variable is declared as static, space for it gets allocated for the lifetime of the program. Even if the function is called multiple times, space for the static variable is allocated only once and the value of variable in the previous call gets carried through the next function call.

也就是说，一旦函数中静态变量声明并赋值后，之后所做的任何改动都会持续到整个程序的生命周期最后，不论这个函数被调用了多少次。

而如果**全局变量**被定义为静态，则只能在定义的文件中使用，不能被其他文件使用，静态函数也一样，除非被定义在头文件中，并被其他文件包含。静态的**局部变量**被储存于静态区，生命周期为整个程序的运行周期，普通局部变量定义在栈中，使用（函数调用）完毕后就会被销毁。

当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有**一个**副本，因此静态成员**不能**在构造函数中初始化。静态成员在类的所有对象中是共享的。在类的**外部**通过使用范围解析运算符`::`来重新声明静态变量从而对它进行初始化。

我们同样可以将一个类的对象声明为静态的，那么这个对象会在这个程序的生命周期中一直存在。

### 静态成员函数

如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数可以在类对象**不存在**的情况下被调用，只要使用类名加范围解析运算符`::`就可以。

* 静态成员函数只能访问**静态成员**数据、其他静态成员函数和类外部的其他函数

* 静态成员函数不能访问类的`this`指针

## 7.多态

多态（polymorphism）指为不同数据类型的实体提供统一的接口。程序执行时，相同的讯息可能会送给多个不同类别的物件，而系统可依据物件所属类别，引发对应类别的方法，而有不同的行为。

### 虚函数

虚函数是在基类中使用关键字`virtual`声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。

### 纯虚函数

我们可以在基类中只定义虚函数而不给出具体的实现，而在不同的派生类中才去实现，这时就会用到纯虚函数。

```c++
virtual int func() = 0;
```

`=0`告诉编译器，这个函数是纯虚函数，没有函数体。

另外父类的虚函数或纯虚函数在子类中依然是虚函数，有时我们并不希望父类的某个函数在子类中被重写，在 C++11 及以后可以用关键字`final`来避免该函数再次被重写。

### 不能声明为虚函数的函数

1. 构造函数，构造函数在生成对象之前就被调用，而虚函数需要调用对象内的虚函数表。

2. 内联函数

3. 静态成员函数，它和对象是分离的

## 8.重载运算符

重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。

```c++
Box operator+(const Box& b){
    Box box;
    box.length = this->length + b.length;
    box.breadth = this->breadth + b.breadth;
    box.height = this->height + b.height;
    return box;
}
```

声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：

```c++
Box operator+(const Box& b1, const Box& b2);
```

## 9.const成员函数

要声明一个const类型的类成员函数，只需要在成员函数参数列表后加上关键字const，如：

```c++
int get() const;
```

若将成员函数声明为`const`，相当于对象所含有的隐式指针`this`指向的是`const`对象，则：

1. 该函数不允许修改类的任何数据成员，不管其是否具有`const`性质

2. 只能访问`const`函数

3. `const`可以作为重载标识符

注意`const`对象**只能**访问`const`成员函数，也不能修改任何成员变量，除非变量被`mutable`修饰。

因此在声明一个成员函数时，若该成员函数并不对数据成员进行修改操作，应尽可能将该成员函数声明为`const`成员函数。