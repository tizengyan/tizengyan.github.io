---
layout: post
title:  "C++面向对象"
date:   2019-02-18 13:22:54
categories: 基础知识
tags: OOP
excerpt: 面向对象编程基础
author: Tizeng
---

* content
{:toc}

## 结构体和类

`struct`和`class`本质上只有两点区别：

* 默认继承权限不同。
    `class`的继承如果不做指定，默认为`private`继承，而`struct`中默认为`public`继承。

* 成员的默认访问权限不同。
    `class`中的成员变量和成员函数默认权限是`private`，而`struct`中默认权限是`public`。

## 构造函数

类的构造函数是一种特殊的成员函数，它会在每次创建类的新对象时执行。构造函数的名称与类的名称必须完全相同，并且不会返回任何类型，也不会返回`void`。构造函数可用于为某些成员变量设置初始值。**析构函数**和构造函数对应，只是在定义时在函数明前加`~`关键字，用于在程序结束时释放内存等。

在构造函数之前加上`explicit`关键字，可以禁止隐式转换。

### 带参数的构造函数

构造函数可以在定义时根据需要加入若干参数，用于对成员变量初始化。假设有一个类A，其中有X、Y、Z三个成员变量（字段），我们可以通过以下初始化列表来简化构造函数：

```c++
A::A( double a, double b, double c): X(a), Y(b), Z(c){}
```

## 拷贝构造函数

拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。以下情况会调用拷贝构造函数：

* 一个对象需要通过另外一个对象进行初始化
    比如用`=`进行赋值

* 一个对象以值传递的方式传入函数体
    此时传入函数的对象会调用拷贝构造函数生成一个新的对象，并在函数执行完毕后析构掉它

* 一个对象以值传递的方式从函数返回

也就是说当该类型的对象传递给函数或从函数返回该类型的对象时，将隐式调用拷贝构造函数。

如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。拷贝构造函数的最常见形式如下：

```c++
classname (const classname &obj) {
   // 构造函数的主体
}
```

## 友元函数（friend function）

类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。

友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。

如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字`friend`，如下所示：

```c++
class Box{
   double width;
public:
   double length;
   friend void printWidth( Box box );
   void setWidth( double wid );
};
```

声明类`ClassTwo`的所有成员函数作为类`ClassOne`的友元，需要在类`ClassOne`的定义中放置如下声明：

```c++
friend class ClassTwo;
```

注意友元函数没有`this`指针，因为友元不是类的成员，只有成员函数才有`this`指针。

## 内联函数（inline function）

C++ 内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。

* 在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符

* 在内联函数内不允许使用循环语句和开关语句

* 内联函数的定义必须出现在内联函数第一次调用之前

* 类结构中所在的类说明内部定义的函数是内联函数

* 尽量当函数只有10行甚至更少时才将其定义为内联函数

## 类的静态成员（static）

首先介绍普通函数中的静态变量：

> When a variable is declared as static, space for it gets allocated for the lifetime of the program. Even if the function is called multiple times, space for the static variable is allocated only once and the value of variable in the previous call gets carried through the next function call.

也就是说，一旦函数中静态变量声明并赋值后，之后所做的任何改动都会持续到整个程序的生命周期最后，不论这个函数被调用了多少次。

当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有**一个**副本，因此静态成员**不能**在构造函数中初始化。静态成员在类的所有对象中是共享的。在类的外部通过使用范围解析运算符`::`来重新声明静态变量从而对它进行初始化。

我们同样可以将一个类的对象声明为静态的，那么这个对象会在这个程序的生命周期中一直存在。

### 静态成员函数

如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数可以在类对象**不存在**的情况下被调用，只要使用类名加范围解析运算符`::`就可以。

* 静态成员函数只能访问**静态成员**数据、其他静态成员函数和类外部的其他函数

* 静态成员函数不能访问类的`this`指针

## 多态

多态（polymorphism）指为不同数据类型的实体提供统一的接口。程序执行时，相同的讯息可能会送给多个不同类别的物件，而系统可依据物件所属类别，引发对应类别的方法，而有不同的行为。

### 虚函数

虚函数是在基类中使用关键字`virtual`声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。

### 纯虚函数

我们可以在基类中只定义虚函数而不给出具体的实现，而在不同的派生类中才去实现，这时就会用到纯虚函数。

```c++
virtual int func() = 0;
```

`=0`告诉编译器，这个函数是纯虚函数，没有函数体。

另外父类的虚函数或纯虚函数在子类中依然是虚函数，有时我们并不希望父类的某个函数在子类中被重写，在 C++11 及以后可以用关键字`final`来避免该函数再次被重写。

## 重载运算符

重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。

```c++
Box operator+(const Box& b){
    Box box;
    box.length = this->length + b.length;
    box.breadth = this->breadth + b.breadth;
    box.height = this->height + b.height;
    return box;
}
```

声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：

```c++
Box operator+(const Box& b1, const Box& b2);
```