---
layout: post
title:  "背包问题总结（下）"
#date:   2019-03-06 12:12:54
categories: 基础算法
tags: dynamic_programming
excerpt: 总结一下多种条件下的背包问题
author: Tizeng
---

* content
{:toc}

解决动态规划的三个基本要素：

1. 最优子结构

2. 边界条件

3. 状态转移方程

现在开始介绍较为复杂的背包问题，这一类问题可能在笔试面试中出现，因此一定要烂熟于心。

## 二维费用的背包问题

二维费用是指除了物品的重量之外，还需要考虑另一种可消耗因素w2[i]（比如体积），即需总重量不超过C1且总体积不可超过C2，这时我们的费用增加了一维，那状态转移方程也要相应的增加一维:

`f[i][j][k] = max( f[i - 1][j][k], f[i - 1][j - w1[i]][k - w2[i]] + v[i])`

然后我们再用前面的思路对它进行优化，将三维降为二维:

```c++
vector<vector<int> > f(C1 + 1, vector<int>(C2 + 1));
for(int i = 0; i < n; i++){
    for(int j = C1; j >= w1[i]; j--)
        for(int k = C2; k >= w2[i]; k--)
            f[j][k] = max(f[j][k], f[j - w1[i]][k - w2[i]] + v[i]);
}
```

这里假设是简单的0-1背包问题，如果是完全背包问题或多重背包问题，只需要按照之前的方法（从左至右、拆分系数）带入就可以了，最后`f[C1][C2]`便是答案。

补充一点，有时第二维的要求会给的比较隐晦，比如所给的物品只有重量，但是总共只能拿 N 件，那就可以理解为每个物品的另一个费用都是1，然后和不能超过 N。

## 分组（互斥）的背包问题

在给定的物品中，除了价值v[i]和重量w[i]外，还将它们分为 k 组，每组中的物品相互冲突，最多只能选一件，此时应该如何选择才能在不超过背包总容量的情况下得到最大价值呢？

我们先改写新的转移状态方程：

`f[k][j] = max{ f[k - 1][j], f[k - 1][j - w[i]] + v[i] | i ∈ group k}`

其中`f[k][j]`表示前 k 组物品在 j 的背包容量下所能取得的最大价值，那么此时有选第 k 组中的物品和不选两种情况，如果不选则完全根据前第 k - 1 组物品决定，如果选，那么需要对第 k 组中的所有物品进行遍历：

```c++
vector<vector<int> > items; // 储存物品的序号，横坐标为组号，纵坐标为组内元素的序号
...
for(int k = 0; k < items.size(); k++)
    for(int j = C; j >= 0; j--)
        for(int i = 0; i < items[k].size(); i++)
            int index = items[k][i];
            if(j >= w[index])
                f[j] = max(f[j], f[j - w[index]] + v[index]);
```

注意`items`储存的是第 k 组中的所有元素的下标，提取的时候要分两步，先输入组号，在依次提取下标。

例题请看另一篇[友塔游戏笔试笔记](https://tizengyan.github.io/2019/02/26/yotta_online_test/)第三题。

## 有依赖的背包问题

如果规定选第 i 件物品必须取第 j 件物品，就说背包中的物品有依赖关系。这里我们假设被依赖的物品不会再依赖其他物品，就是说不会出现多层依赖。



### 例题

题目描述：有两排宝箱，第一排长 n ，第二排长 m ，每个宝箱装有一定数量的财宝，开宝箱有两条规则

1. 宝箱必须间隔开，比如开了某排的第 i 个宝箱，那么就不能开第 i + 1 和第 i - 1 个

2. 第一排宝箱和第二排宝箱有一个交点，给定 a 和 b ，如果开了第一排的第 a 个宝箱，那么必须开第二排的第 b 个宝箱

问如何选取宝箱才能获得最多的财宝？

## 求方案总数

## 求最优方案总数

## 求次优解

再次感谢《[背包问题九讲](https://github.com/tianyicui/pack)》中的详细讲解。