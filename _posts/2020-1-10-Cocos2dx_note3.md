---
layout: post
title:  "Cocos2dx开发笔记3"
categories: 游戏开发
tags: Cocos2dx
excerpt: zt业务逻辑
author: Tizeng
---

* content
{:toc}

此笔记以Mac系统为平台。

## 服务器通信

如何接收服务器发来的消息？

以背包数据为例，`obj_PackData`方法接收背包的初始化消息，收到消息的过程为，Callback.lua脚本中处理服务器发来的消息，先分发给`DataManeger`，然后在分发给`UIManager`，调用的是各自的`dispatchMsg`方法，传入消息名称（`obj_PackData`）和数据包。`DataManager`在初始化时会包含所有处理消息的脚本名以及它们的实例，然后以传入的消息名索引对应的方法，缓存在本地，然后调用。`UIManager`的实现有所不同，每创建一个panel，`UIManager`都会按该panel的名字将其储存进一个表，分发时遍历所有已储存的panel并以传进的函数名索引查找该函数，如果找到则调用。

之前的bbl项目中若要接收服务器消息需要在脚本开头先注册消息名称，是因为在该项目中`DataManager`在分发消息前按接收消息的名称储存了该脚本的实例，然后分发时用消息名称索引需要接收该消息的实例，调用相应的方法，这样做的好处是不用每次收到消息时都去遍历有哪些数据脚本需要该消息，提升性能。`UIManager`也是类似，为了不在每次收到消息时都去遍历所有ui，也按照消息的名称来储存所有需要该消息的实例。在关闭ui时，释放空间的操作是在`UIManager`中的update方法中，目的是在下一帧才执行我们的释放操作，这样可以防止在同一帧内发生多次创建和删除操作。

proto消息长度不能超过32个字符，否则会被截断。

## 配置读取

`g_DataManager`中的`getXmlData`和`getExeclData`负责读取xml和excel配置。

## 上漂提示和确认弹窗

大部分上漂和提示在`ChatData`中的`showGameMsgTips`方法实现，根据传入不同的提示类型调用不同的方法去显示，确认弹窗在`showMessageBoxMedium`方法实现。

## 注册回调函数

首先看`handler`和`registerClockHandler`方法的实现：

```lua
function handler(obj, method)
    return function (...)
        return method(obj, ...)
    end
end

-- 类A中实现的注册方法
function M:registerClickHandler(obj, func, ...)
    if type(func) == "function" then 
        self.m_clickCallbackArgs = {...}
        self.m_clickCallbackFunc = handler(obj, func)
    else
        self.m_clickCallbackArgs = nil
        self.m_clickCallbackFunc = nil
    end
end

-- 类A中使用回调
function M:onClick(touch, event)
    if self.m_clickCallbackFunc then 
        self.m_clickCallbackFunc(self, unpack(self.m_clickCallbackArg))
    end
end

-- 在另一个类B中生成这个类的实例instance，然后注册类B中的方法为类A实例的回调
-- instance:registerClickHandler(selfB, selfB.someFunction)
```

外部生成实例后若想注册点击回调函数，则直接向上面一样调用`registerClickHandler`方法，也就是说这里想把类B的一个方法注册为类A实例的回调函数，至于该回调在何时调用我们不关心，注册时传入的self是类B的self，进入`registerClickHandler`后`hanlder`方法会将其作为obj参数传入，并作为第一个参数传入`self.someFunction`，注意这里`handler`返回的并不是`self.someFunction`这个方法本身，而是一个匿名函数：

```lua
function(...) 
    return instanceB.someFunction(selfB, ...)
end
```

因此最后调用类A的方法`onCLick`时，其中作为参数传入的self是类A的实例，就算后面的参数列表为`nil`，它也会作为唯一的参数传入`self.someFunction(selfB, selfA)`。

## 创建UI

创建ui在`UIManager`中有两个接口，一个是`getOrCreatePanel`，它会先调用`getPanel`去取，如果取不到则调用用`createPanel`方法创建ui并返回，`UIManager`会储存每个创建的实例（创建是调用的`Node`节点中的`create`方法）。而如果是用`createPanelOnly`创建的ui，就不能用`getOrCreatePanel`方法来获得实例，因为它没有在`UIManager`中保存已创建ui的实例，直接调用会导致后者再以自己的方式创建并储存该ui，一般来说调用了`createPanelOnly`的类中会自己储存ui的实例，然后实现相应的get方法去取，我们应该去调用这些get方法。

有一类ui的创建较为特殊，道具点击后弹出的小弹窗，根据道具种类不同，弹窗上的按钮种类可能有区别，也可能需要不同的回调函数，创建背包界面时面对茫茫多的道具，显然应该封装一个方法来处理不同道具的callback，背包中首先为每个道具创建空的`UIItemIconBg`实例，然后根据道具data中的grid格子坐标获取itemData，然后用itemData去初始化创建的格子，其中便包括给其注册正确的callback函数，通常情况下（没有需要对比的其他道具），这个callback先创建`UIBaseTips`，它是tips的基本背景图（后面也会根据道具的data切换），然后根据该道具的baseid得到需要显示的按钮btnList，tips中按钮也需要回调，所有这些回调函数统一定义在`UITipsConfig`中，按类型进行索引，然后给当前物品弹窗tips设置正确的回调。

### 衣橱系统新功能（2020.2.19）

在衣橱ui中加入一个“进阶”页签，让衣品达到十段的外套可以继续升钻，点击提升按钮后弹出可选择提升材料的窗口，选择后点击确定消耗材料，提升外套经验，达到当前等级要求的经验后升一颗钻，按白蓝黄绿紫的顺序，每种颜色有五级，升满后变为下一个颜色，直到紫5。

这本身是一个很基础的功能，但却比预期的时间晚了24个小时才完成，主要的原因有二，一是上面总结的get和创建ui的方法使用不当，导致get到了错误的ui实例，界面收到服务器消息后没有实时刷新；二是没有很快理解`UIWardrobChoose`这个ui的创建逻辑，把自己绕进去了，浪费了很多时间。

总结来说这个功能无非就是调用之前已经写好的各种ui的api，很多东西已经是实现好的，只有`UIWardrobChoose`这个类，由于之前只有一个地方使用，里面做了一些特殊处理，现在把它优化成可以在衣橱系统下通用的接口，触发条件和回调函数由外部传入。

### 道具通用点击tips

有很多地方需要显示道具icon，而这些icon通常是可以点击的，点击后会弹出一个tips显示道具的各种信息，名称、品类、简介等，这就需要用到PackageData中的显示通用tips的方法，创建icon实例后，调用之前描述的`registerClickHandler`方法，将显示tips的方法注册给icon，然后通过道具的baseid去初始化tips的界面。

### 愚人节活动（2020.3.20）

活动页面显示三个道具，只有一个是真道具，根据用户的选择获得标注数量的真道具，如果猜错获得一半数量。根据配置显示服务器发过来的道具，发过来的消息会包含配置中的index，用这些index读baseid，然后正确的初始化itemicon。

用户上次的选择：要求是界面在用户选择道具后显示猜中和猜错两种文字，直到下一次活动开启前，关闭ui或重新登录后再打开活动界面都可以看到上次选择的结果。首先是可以参与活动的情况，选择之前服务器会告知客户端哪个是真道具，在玩家选择后将其与玩家的选择比对，根据结果刷新ui；然后是在下一次活动开始前打开界面，这时ui的初始化就要用到上次选择的结果，这个信息问data要，我们在每次选择后都会将正确与否储存在data中，而如果是重新登录，服务器发来的消息也包含上一次的选择结果。

刷新ui：分三种情况，当不需要倒计时且剩余次数大于零时，刷新真假道具icon和描述；当次数为0时显示无次数文本，描述为上次选择的结果；最后一种则是需要倒计时，显示倒计时文本和描述（上次选择的结果），同时刷新道具icon为真道具。

倒计时：下一次活动开启前打开界面会有格式为“x分x秒”的倒计时，首先想到用update方法每帧去查询下次活动开始时间与服务器时间的差值，如果大于零则说明需要倒计时，然后利用帧间隔做减法，取到整数部分更新到屏幕上。由于显示的时间只精确到秒，所以没有必要每帧都去刷新ui，可以存一个累计变量，当它达到一秒后，再对时间做更新。要注意的是，判断是否需要倒计时是通过查询下次活动开始时间与服务器时间的差值，ui界面刷新时会受到这个结果的影响，目前设置的阈值是1，也就是说只有当差值大于1时才说明需要计时，不设成0是为了防止服务器在时间相等后发送了更新消息，在更新消息中刷新ui时如果判断为真则会去初始化倒计时而不刷新道具icon了。

序列帧动画播放：如果要用sequence创建序列事件，运行`runAction`的不能是ui自己，要单独创建一个sprite，然后用这个spite去run，要特别注意，就算是播放序列帧动画，期间发生的变换也是未知的，因此这个sprite上最好不能有任何别的需要显示的东西，否则播放动画时会出现不可预测的问题。位置就是这个sprite的位置，我们希望动画在屏幕正中间播放，那么可以将这个sprite移到ui的中间，创建时我们将其加入了ui背景的child，默认会在背景的左下角，只需要将sprite的坐标设为背景长宽的一半就到了正中间（注意是背景size，不是ui的size）。

禁止用户操作：要求在播放动画时禁止用户输入，只需要维护一个变量记录是否正在播放动画，在执行动画播放时置为true，在动画播放完调用回调时置为false，然后在每个按钮点击时加入这个变量的判断，只有在未播放动画时才响应点击。

动画背景遮罩：在播放动画时为了突出动画效果，需要在背景生成一个黑色半透明遮罩，实现的方式参考显示ui时背景的遮罩，创建一个`LayerColor`，大小为`cc.Director:getInstance():getVisibleSize()`，即窗口大小，然后将其加入ui的child，并在适当的时候显示。

道具icon环绕特效：根据道具的品质在icon周围显示相应颜色的环绕特效，其实也是一个序列帧动画，只是会不停播放，然后是颜色，品质环绕动画的颜色是纯白，我们根据道具的baseid拿到quality之后，根据配置中的颜色来对icon中的`effect2`成员设置颜色，这样环绕动画的颜色也会变成相应的颜色，因为序列帧是通过这个成员run的。

场景载入完成后上漂：这里的关键是如何判断当前场景已经载入完毕，载入界面在关闭时会调用`GameData`中的方法告知其场景已经完成载入，然后`GameData`会依次告知所有data类型的脚本，再在data脚本中做相应的处理，因此要先将处理函数注册给`GameData`。

*Bug1*：本地计算时间时，每次累计超过一秒就将时间减一，这样其实每次都会累计一点误差，当倒计时比较长的时候会累积到比较大的误差，导致超过与服务器同步时间的阈值，解决办法是每秒直接同步服务器时间，不本地去减了，其实也可以改成减去累计的实际时间，即比一秒钟多一点的时间消除误差，但是为了保险还是直接同步吧，反正也每帧去对比了，如果某个地方出现误差并且累计了，阈值设多高都没有意义。

*Bug2*：最后一轮活动参与的倒计时到了之后界面不刷新，原因是ui刷新的时刻是收到服务器消息的时候，刷新的方法会检查时间差，小于差值才刷新，如果提前收到了消息就不会刷新了，解决方法是本地再弄一个倒计时，到点了就刷，这样不管是否提早收到了消息，都能保证屏幕一定被刷新。

*Bug3*：之前参加了活动，活动结束之后，切换地图显示有活动上漂，原因是显示上漂时没有判断是否在活动时间内，想当然的以为服务器会告知。

几个bug问题都是出在边界条件的处理上，还有服务器跨零点或者活动结束时的情况，以后一定要记得考虑到，多测试。

### UI注意事项

（1）有时ui的回调函数需要用到闭包，即在回调函数外创建的panel实例，在回调函数中使用，直接使用该实例是不安全的，如果这个ui在外部已经被析构，那么触发回调函数时这个panel就会变成野指针，正确的做法是通过`UIManager`去get，而且一定要记得get了之后每次使用自己ui实例的时候都要进行判空，否则就没有意义了。

（2）创建ui后要记得马上调用`showToScene`方法，否则在该帧结束时会被cocos的内存管理回收。

（3）创建新ui时，有两个问题要注意，一个是灰色遮罩，需要手动激活显示，另一个是zorder层级，要在配置文件中设置zorder值。

## 寻路

寻路实现在`GodConfig`脚本中，其中`goto`方法是通过`pathID`读取路线中NPC等配置，通过一系列的条件判断，最后在回调函数中调用`moveTo`方法开启寻路。注意如果在调用事件(addCallEvent)中使用了多于一个的事件，那除第一个事件的其他事件都要继续使用`add***Event`方法加入事件处理队列。
如果在副本中要先去pathID对应的一个坐标处，再调用一次`goto`或`moveTo`去最终的目标点。如果目标国家不是当前国家，就要跨国寻路，跨国寻路时要先寻路到*边境*，寻路接口在`TransportData`脚本中，如果返回为`true`则说明寻路成功，调用`gotoTransport`方法去到目标点（存疑)。如果目标点就在当前地图，当与目标点距离比期望值大时，调用主角脚本的`addMoveEvent`方法。
如果是同一个国家的不同地图，就要考虑地图之间传送点的问题，`TransportData`中的方法`findPath`就是搜索不同地图间的传送点，算法就是简单的广度优先搜索，得到从当前地图到达目标地图所需的最少*传送点*的列表，然后去列表中第一个传送点的位置，即递归的调用`goto`或`moveTo`，知道到达目标点位置。

主角脚本中有一个成员`mInputCommandQueue`用来储存输入的事件，然后每帧会被`processInput`方法处理，MoveEvent会被`on_MoveEvent`方法处理，最后调用的也是`god.moveTo`方法。

角色本身的移动逻辑是在自身脚本中的`moveTo`方法中实现，这个方法继承自`SceneNpc`脚本，最后调用的是c++中的`cCharacterExt.requestPath`方法，经过一系列传递后在CAStar.cpp中的`FindPath`方法实现寻路，实现是基本的A*寻路，用map作为开闭表记录搜索的节点，通过计算节点xy坐标的哈希值来索引。寻路完成后，路径会保存在成员`m_Path`中，然后每次查询下一个节点，就会把该节点储存到成员`m_PathPreNode`中，再用专门的方法去访问它的xy坐标。

## zt技能系统

### 选定目标
### 攻击检查
### 伤害结算

### 远程攻击反馈

角色攻击时如果是远程攻击，当弹道到达目标点时，C++会调用lua脚本`PopNumberManager`的`onMagicBoom`方法显示上漂数值，需要显示的数字根据attacker、target、skillid作为索引储存在一个表中，其中还存有当前的服务器时间，最后准备显示时，根据与服务器的时间戳比对，只显示与当前时间相同的数字，具体显示的方法在`cCharacterExt.cpp`中定义，由脚本`SceneNpc.lua`调用，最终在`GameScene.cpp`的`Update`方法中每帧更新要显示的数字（如果有）。

## zt任务系统

类似于很多其他rpg游戏，界面左侧会有一个任务列表，根据任务的优先级由上往下显示若干任务描述，点击后角色会开始自动寻路，如果是敌人则自动攻击，如果是NPC则开启对话，并在结束后（击杀敌人数量达到任务要求或完成对话）自动开始该任务的下一个流程，期间如果用户有移动输入，会打断寻路，这应该和寻路的逻辑有关。

用户直接点击NPC和点击任务标签的区别？

## Cocos的内存回收机制

以下内容部分为《我所理解的Cocos2d-x》的读书笔记，部分为wiki词条的翻译。

Cocos2d-x没有使用C++11的智能指针来管理内存，原因有二，一是智能指针在性能上会有比较大的损失，shared_ptr为了保证线程安全，必须使用一定形式的互斥锁来保证所有线程访问时其引用计数正确，这对游戏这种实时性很高的程序而言是不可接受的；二是在显式的创建智能指针和引用的语法不够自然（我对这点存疑）。

引用计数：常用的垃圾回收方法，记录对象被引用的次数，被引用时计数加一，引用被销毁时计数减一，当计数为0时就认为这个对象可以被回收了。它的优点是可以尽快回收不被使用的对象，对CPU的负担较小。

基于追踪：最常用的垃圾回收方法，简单来说就是区分哪些对象已经可以被释放空间（deallocate），哪些是从某些根对象（root objects）可以被拿到的（reachable），通常是正在使用的对象，剩下的就是可以被收集的垃圾了。

引用计数之于追踪的优点是对象会在没有被引用时马上就被回收，不需要等到回收周期再回收，这在实时性和有限的内存下非常重要，引用计数实现起来也较为简单。但它相比较追踪策略有两个主要缺陷：

1. 频繁的更新是低效率的源头，而追踪法可以通过上下文切换（context switching）等方法极大的影响性能，收集垃圾的过程往往不频繁。其次，引用计数法对每个内存管理的对象都要预留储存计数的空间，而在追踪法中，这些信息被隐性（implicitly）的储存在指向对象的引用中；
2. 循环引用，即两个或以上的对象互相引用形成循环的话，因引用计数就永远不会归零了，对于这个问题可以用弱引用（weak reference）策略，让那些往回指的指针（backpointers）不计入引用计数，此外，弱引用是安全的，因为当引用对象变为垃圾时，对其的任何弱引用都会失效，而不是允许其保持悬空状态，这意味着它变成了可预测的值，例如空引用。

Cocos2d-x中的所有对象几乎都继承自`Ref`基类，它的主要职责就是对对象进行引用计数管理，当用`new`运算符分配内存时，引用计数为1，调用`retain()`方法引用计数加1，调用`release()`方法则会使引用计数减1，当引用计数归零时`release()`方法会调用`delete`运算符删除对象并释放内存。同时，我们可以通过`autorelease()`方法声明一个指向对象的“智能指针”，这些指针会全部加入*AutoreleasePool*中，每一帧结束时会对pool中的对象进行清理，也就是说该指针的**生命周期**为从创建到当前帧结束。清理的机制是，*AutoreleasePool*对池中每个对象执行一次release操作，因此如果一个对象被创建，但它在这一帧从未被使用，那么执行该操作后会马上被释放。Ref的引用计数并不是线程安全的，在多线程中，我们需要通过处理互斥锁来保证线程的安全。

为了简化声明（先`new`再`autorelease()`），Cocos2d-x使用static方法`create()`来返回一个指针对象，大部分类都可以用这个方法创建。

这就解释了，在zt项目中，用UIManager的`getOrCreatePanel`方法创建的ui如果不马上调用`showToScene`方法的话，会下一帧就会被析构。

## tableview、scrollview

先来看一下背包道具格子实现，zt中背包格子并没有使用tableview，而是直接用了scrollview，根据背包的布局一个个的创建格子`UIItemIconBg`，并把它们设置到正确的位置，然后根据背包数据去初始化有道具格子的表现。

再来看福利菜单页签，它由左边的列表和右边的若干界面组成，左边的列表使用了tableview，创建tableview实例后根据左边列表节点的预设大小初始化，经过其他常规初始化后将实例添加为节点的孩子节点，然后调用`registerScriptHandler`为tableview注册回调函数，一般来说有四个需要注册，被触摸的回调（cc.TABLECELL_TOUCHED)、tableview中cell的尺寸（cc.TABLECELL_SIZE_FOR_INDEX）、tableview某个位置的cell（cc.TABLECELL_AT_INDEX）、cell的数量（cc.NUMBER_OF_CELLS_IN_TABLEVIEW）。第一个很直观，就是点击回调，具体看要什么功能了，如果一行需要显示多个item每个item有单独的点击回调，就不需要定义这个回调，而对每个item单独设置。第二个和第四个比较好理解，尺寸一般不会变，回调的返回值可以直接写死，数量可以根据需要显示的item布局的高度来返回，因为滑动的每个cell就是单独的一行。第三个回调需要根据idx正确的返回cell的实例，由于tableview为了节省空间只会生成总量多于可视范围内若干数量的cell，实际上是通过这个方法来知道滑动时应该显示哪些cell，如果是第一次调用这个方法，则需要创建tableviewCell，然后将要显示在cell的ui界面加到它的孩子节点。

## 主界面技能轮盘

主要是旋转的操作，通过比较横纵坐标从点击起始点和后面移动点变化的差值，来决定是顺时针旋转还是逆时针旋转，还是回到起始点，旋转时如果玩家按住轮盘移动，轮盘会跟着手指同步移动，此时是用横纵坐标之和除以二来近似旋转角度，实时设置旋转角，松开手指后根据幅度将轮盘归位，这里使用了`rotateTo`方法，使轮盘根据输入的index转到指定位置。注意旋转的是轮盘九个技能icon的父节点，因此旋转后技能icon会偏移，要依次将它们朝相反反向旋转回正确的朝向。

## 选国功能移植（2020.4.15）

拒绝堆屎山。拒绝不了的时候只能优雅的根据屎山的结构尽量去优化。
本来这个功能是版本1的，现在要移植到版本2，版本1只有三个国家，实现很蛋疼，三个国旗可以选择，csd里面就拼了三个一模一样的节点，然后手动加载了不同的国旗图，版本2现在有十个国家，就要重复十次相同的操作，由于这是登录创角界面，不能有任何差错，因此我就傻x的还按之前的结构每个需要用到的节点都去注册，只对使用它们的方式做了优化，之前是同一种操作根据不同国家输入写三次，我把需要操作的节点存入若干table，然后用countryid作为索引直接遍历，但是节点还是一个个去注册了，这就导致如果策划改动了csd中的父子结构，设置可见性时就会受影响。最理想的实现方式应该是把每个国旗弄一个单独的csd，然后初始化选国界面的时候依次按国家data去初始化，这样任何改动只需要做一次，也不用复制粘贴节点，最多就是多了一步读配置的操作。但目前策划保证这个界面不会有新的改动（之前也是这么说的，导致我偷懒没有把版本1的代码优化干净），为了节省时间，通过每个国旗的父子关系使用getChildByName方法拿需要的节点，这样就只需要注册十个国旗最上层的节点，前提是父子结构未来不会更改，否则代码又要改。其实稍微想想就知道这样的实现同样不符合ETC（easier to change）原则，完全依赖策划对未来的保证，如果下次再动一定要优化成单独的cell。

itemicon的大小是定死的78x78像素，但会根据所在父节点scale变化。如果有地方整体变大或变小了，可以根据变化的比例去设置icon的scale同步变化。

### 创角界面的动画

新建角色界面中，选择诸如发色、性别等属性时，各属性ui选择后会从上方飞入，这是CocosStudio中做好的动画，

### 退出选角界面后长时间的转圈表现

Callback脚本中定义了一些全局方法，显示转圈界面的方法就定义在里面，在UILogin中请求服务器列表时，执行了一个序列，让UICircle转了20秒，把这个时间调很短之后，发现登录界面的选服半天不刷，推测是为了强行掩盖这个表现。

## 小地图实现

## lua与c++的互调

## 摄像机，九屏

## 打图，读整图，res

plist、pvr.ccz、TexturePacker

## proto消息，c++消息

## tolua
