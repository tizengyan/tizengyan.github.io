---
layout: post
title:  "Cocos2dx开发笔记3"
categories: 游戏开发
tags: Cocos2dx
excerpt: zt业务逻辑
author: Tizeng
---

* content
{:toc}

此笔记以Mac系统为平台。

## 服务器通信

如何接收服务器发来的消息？

以背包数据为例，`obj_PackData`方法接收背包的初始化消息，收到消息的过程为，Callback.lua脚本中处理服务器发来的消息，先分发给`DataManeger`，然后在分发给`UIManager`，调用的是各自的`dispatchMsg`方法，传入消息名称（`obj_PackData`）和数据包。`DataManager`在初始化时会包含所有处理消息的脚本名以及它们的实例，然后以传入的消息名索引对应的方法，缓存在本地，然后调用。`UIManager`的实现有所不同，每创建一个panel，`UIManager`都会按该panel的名字将其储存进一个表，分发时遍历所有已储存的panel并以传进的函数名索引查找该函数，如果找到则调用。

之前的bbl项目中若要接收服务器消息需要在脚本开头先注册消息名称，是因为在该项目中`DataManager`在分发消息前按接收消息的名称储存了该脚本的实例，然后分发时用消息名称索引需要接收该消息的实例，调用相应的方法，这样做的好处是不用每次收到消息时都去遍历有哪些数据脚本需要该消息，提升性能。`UIManager`也是类似，为了不在每次收到消息时都去遍历所有ui，也按照消息的名称来储存所有需要该消息的实例。在关闭ui时，释放空间的操作是在`UIManager`中的update方法中，目的是在下一帧才执行我们的释放操作，这样可以防止在同一帧内发生多次创建和删除操作。

proto消息长度不能超过32个字符，否则会被截断。

### 优缺点



## 配置读取

`g_DataManager`中的`getXmlData`和`getExeclData`负责读取xml和excel配置。

## 上漂提示和确认弹窗

大部分上漂和提示在`ChatData`中的`showGameMsgTips`方法实现，根据传入不同的提示类型调用不同的方法去显示，确认弹窗在`showMessageBoxMedium`方法实现。

## 注册回调函数

首先看`handler`和`registerClockHandler`方法的实现：

```lua
function handler(obj, method)
    return function (...)
        return method(obj, ...)
    end
end

-- 类A中实现的注册方法
function M:registerClickHandler(obj, func, ...)
    if type(func) == "function" then 
        self.m_clickCallbackArgs = {...}
        self.m_clickCallbackFunc = handler(obj, func)
    else
        self.m_clickCallbackArgs = nil
        self.m_clickCallbackFunc = nil
    end
end

-- 类A中使用回调
function M:onClick(touch, event)
    if self.m_clickCallbackFunc then 
        self.m_clickCallbackFunc(self, unpack(self.m_clickCallbackArg))
    end
end

-- 在另一个类B中生成这个类的实例instance，然后注册类B中的方法为类A实例的回调
-- instance:registerClickHandler(selfB, selfB.someFunction)
```

外部生成实例后若想注册点击回调函数，则直接向上面一样调用`registerClickHandler`方法，也就是说这里想把类B的一个方法注册为类A实例的回调函数，至于该回调在何时调用我们不关心，注册时传入的self是类B的self，进入`registerClickHandler`后`hanlder`方法会将其作为obj参数传入，并作为第一个参数传入`self.someFunction`，注意这里`handler`返回的并不是`self.someFunction`这个方法本身，而是一个匿名函数，相当于：

```lua
function(...) 
    return instanceB.someFunction(selfB, ...)
end
```

因此最后调用类A的方法`onCLick`时，其中作为参数传入的self是类A的实例，就算后面的参数列表为`nil`，它也会作为唯一的参数传入`self.someFunction(selfB, selfA)`。

## 创建UI

创建ui在`UIManager`中有两个接口，一个是`getOrCreatePanel`，它会先调用`getPanel`去取，如果取不到则调用用`createPanel`方法创建ui并返回，`UIManager`会储存每个创建的实例（创建是调用的`Node`节点中的`create`方法）。而如果是用`createPanelOnly`创建的ui，就不能用`getOrCreatePanel`方法来获得实例，因为它没有在`UIManager`中保存已创建ui的实例，直接调用会导致后者再以自己的方式创建并储存该ui，一般来说调用了`createPanelOnly`的类中会自己储存ui的实例，然后实现相应的get方法去取，我们应该去调用这些get方法。

有一类ui的创建较为特殊，道具点击后弹出的小弹窗，根据道具种类不同，弹窗上的按钮种类可能有区别，也可能需要不同的回调函数，创建背包界面时面对茫茫多的道具，显然应该封装一个方法来处理不同道具的callback，背包中首先为每个道具创建空的`UIItemIconBg`实例，然后根据道具data中的grid格子坐标获取itemData，然后用itemData去初始化创建的格子，其中便包括给其注册正确的callback函数，通常情况下（没有需要对比的其他道具），这个callback先创建`UIBaseTips`，它是tips的基本背景图（后面也会根据道具的data切换），然后根据该道具的baseid得到需要显示的按钮btnList，tips中按钮也需要回调，所有这些回调函数统一定义在`UITipsConfig`中，按类型进行索引，然后给当前物品弹窗tips设置正确的回调。

### 衣橱系统新功能（2020.2.19）

在衣橱ui中加入一个“进阶”页签，让衣品达到十段的外套可以继续升钻，点击提升按钮后弹出可选择提升材料的窗口，选择后点击确定消耗材料，提升外套经验，达到当前等级要求的经验后升一颗钻，按白蓝黄绿紫的顺序，每种颜色有五级，升满后变为下一个颜色，直到紫5。

这本身是一个很基础的功能，但却比预期的时间晚了24个小时才完成，主要的原因有二，一是上面总结的get和创建ui的方法使用不当，导致get到了错误的ui实例，界面收到服务器消息后没有实时刷新；二是没有很快理解`UIWardrobChoose`这个ui的创建逻辑，把自己绕进去了，浪费了很多时间。

总结来说这个功能无非就是调用之前已经写好的各种ui的api，很多东西已经是实现好的，只有`UIWardrobChoose`这个类，由于之前只有一个地方使用，里面做了一些特殊处理，现在把它优化成可以在衣橱系统下通用的接口，触发条件和回调函数由外部传入。

### 道具通用点击tips

### 愚人节活动（2020.3.20）

活动页面显示三个道具，只有一个是真道具，根据用户的选择获得标注数量的真道具，如果猜错获得一半数量。根据配置显示服务器发过来的道具，发过来的消息会包含配置中的index，用这些index读baseid，然后正确的初始化itemicon。

用户上次的选择：要求是界面在用户选择道具后显示猜中和猜错两种文字，直到下一次活动开启前，关闭ui或重新登录后再打开活动界面都可以看到上次选择的结果。首先是可以参与活动的情况，选择之前服务器会告知客户端哪个是真道具，在玩家选择后将其与玩家的选择比对，根据结果刷新ui；然后是在下一次活动开始前打开界面，这时ui的初始化就要用到上次选择的结果，这个信息问data要，我们在每次选择后都会将正确与否储存在data中，而如果是重新登录，服务器发来的消息也包含上一次的选择结果。

刷新ui：分三种情况，当不需要倒计时且剩余次数大于零时，刷新真假道具icon和描述；当次数为0时显示无次数文本，描述为上次选择的结果；最后一种则是需要倒计时，显示倒计时文本和描述（上次选择的结果），同时刷新道具icon为真道具。

倒计时：下一次活动开启前打开界面会有格式为“x分x秒”的倒计时，首先想到用update方法每帧去查询下次活动开始时间与服务器时间的差值，如果大于零则说明需要倒计时，然后利用帧间隔做减法，取到整数部分更新到屏幕上。由于显示的时间只精确到秒，所以没有必要每帧都去刷新ui，可以存一个累计变量，当它达到一秒后，再对时间做更新。要注意的是，判断是否需要倒计时是通过查询下次活动开始时间与服务器时间的差值，ui界面刷新时会受到这个结果的影响，目前设置的阈值是1，也就是说只有当差值大于1时才说明需要计时，不设成0是为了防止服务器在时间相等后发送了更新消息，在更新消息中刷新ui时如果判断为真则会去初始化倒计时而不刷新道具icon了。

序列帧动画播放：如果要用sequence创建序列事件，运行`runAction`的不能是ui自己，要单独创建一个sprite，然后用这个spite去run，要特别注意，就算是播放序列帧动画，期间发生的变换也是未知的，因此这个sprite上最好不能有任何别的需要显示的东西，否则播放动画时会出现不可预测的问题。位置就是这个sprite的位置，我们希望动画在屏幕正中间播放，那么可以将这个sprite移到ui的中间，创建时我们将其加入了ui背景的child，默认会在背景的左下角，只需要将sprite的坐标设为背景长宽的一半就到了正中间（注意是背景size，不是ui的size）。

禁止用户操作：要求在播放动画时禁止用户输入，只需要维护一个变量记录是否正在播放动画，在执行动画播放时置为true，在动画播放完调用回调时置为false，然后在每个按钮点击时加入这个变量的判断，只有在未播放动画时才响应点击。

动画背景遮罩：在播放动画时为了突出动画效果，需要在背景生成一个黑色半透明遮罩，实现的方式参考显示ui时背景的遮罩，创建一个`LayerColor`，大小为`cc.Director:getInstance():getVisibleSize()`，即窗口大小，然后将其加入ui的child，并在适当的时候显示。

### UI注意事项

（1）有时ui的回调函数需要用到闭包，即在回调函数外创建的panel实例，在回调函数中使用，直接使用该实例是不安全的，如果这个ui在外部已经被析构，那么触发回调函数时这个panel就会变成野指针，正确的做法是通过`UIManager`去get。

（2）创建ui后要记得马上调用`showToScene`方法，否则在该帧结束时会被cocos的内存管理回收。

（3）创建新ui时，有两个问题要注意，一个是灰色遮罩，需要手动激活显示，另一个是zorder层级，要在配置文件中设置zorder值

## 寻路

寻路实现在`GodConfig`脚本中，其中`goto`方法是通过`pathID`读取路线中NPC等配置，通过一系列的条件判断，最后在回调函数中调用`moveTo`方法开启寻路。注意如果在调用事件(addCallEvent)中使用了多于一个的事件，那除第一个事件的其他事件都要继续使用`add***Event`方法加入事件处理队列。
如果在副本中要先去pathID对应的一个坐标处，再调用一次`goto`或`moveTo`去最终的目标点。如果目标国家不是当前国家，就要跨国寻路，跨国寻路时要先寻路到*边境*，寻路接口在`TransportData`脚本中，如果返回为`true`则说明寻路成功，调用`gotoTransport`方法去到目标点（存疑)。如果目标点就在当前地图，当与目标点距离比期望值大时，调用主角脚本的`addMoveEvent`方法。
如果是同一个国家的不同地图，就要考虑地图之间传送点的问题，`TransportData`中的方法`findPath`就是搜索不同地图间的传送点，算法就是简单的广度优先搜索，得到从当前地图到达目标地图所需的最少*传送点*的列表，然后去列表中第一个传送点的位置，即递归的调用`goto`或`moveTo`，知道到达目标点位置。

主角脚本中有一个成员`mInputCommandQueue`用来储存输入的事件，然后每帧会被`processInput`方法处理，MoveEvent会被`on_MoveEvent`方法处理，最后调用的也是`god.moveTo`方法。

角色本身的移动逻辑是在自身脚本中的`moveTo`方法中实现，这个方法继承自`SceneNpc`脚本，最后调用的是c++中的`cCharacterExt.requestPath`方法，经过一系列传递后在CAStar.cpp中的`FindPath`方法实现寻路，实现是基本的A*寻路，用map作为开闭表记录搜索的节点，通过计算节点xy坐标的哈希值来索引。寻路完成后，路径会保存在成员`m_Path`中，然后每次查询下一个节点，就会把该节点储存到成员`m_PathPreNode`中，再用专门的方法去访问它的xy坐标。

## zt技能系统

### 选定目标
### 攻击检查
### 伤害结算

### 远程攻击反馈

角色攻击时如果是远程攻击，当弹道到达目标点时，C++会调用lua脚本`PopNumberManager`的`onMagicBoom`方法显示上漂数值，需要显示的数字根据attacker、target、skillid作为索引储存在一个表中，其中还存有当前的服务器时间，最后准备显示时，根据与服务器的时间戳比对，只显示与当前时间相同的数字，具体显示的方法在`cCharacterExt.cpp`中定义，由脚本`SceneNpc.lua`调用，最终在`GameScene.cpp`的`Update`方法中每帧更新要显示的数字（如果有）。

## zt任务系统

## tolua

## Cocos的内存回收机制

以下内容部分为《我所理解的Cocos2d-x》的读书笔记，部分为wiki词条的翻译。

Cocos2d-x没有使用C++11的智能指针来管理内存，原因有二，一是智能指针在性能上会有比较大的损失，shared_ptr为了保证线程安全，必须使用一定形式的互斥锁来保证所有线程访问时其引用计数正确，这对游戏这种实时性很高的程序而言是不可接受的；二是在显式的创建智能指针和引用的语法不够自然（我对这点存疑）。

引用计数：常用的垃圾回收方法，记录对象被引用的次数，被引用时计数加一，引用被销毁时计数减一，当计数为0时就认为这个对象可以被回收了。它的优点是可以尽快回收不被使用的对象，对CPU的负担较小。

基于追踪：最常用的垃圾回收方法，简单来说就是区分哪些对象已经可以被释放空间（deallocate），哪些是从某些根对象（root objects）可以被拿到的（reachable），通常是正在使用的对象，剩下的就是可以被收集的垃圾了。

引用计数之于追踪的优点是对象会在没有被引用时马上就被回收，不需要等到回收周期再回收，这在实时性和有限的内存下非常重要，引用计数实现起来也较为简单。但它相比较追踪策略有两个主要缺陷：

1. 频繁的更新时低效率的源头，而追踪法可以通过上下文切换（context switching）等方法极大的影响性能，收集垃圾的过程往往不频繁。其次，引用计数法对每个内存管理的对象都要预留储存计数的空间，而在追踪法中，这些信息被隐性（implicitly）的储存在指向对象的引用中；
2. 循环引用，即两个或以上的对象互相引用形成循环的话，因引用计数就永远不会归零了，对于这个问题可以用弱引用（weak reference）策略，让那些往回指的指针（backpointers）不计入引用计数，此外，弱引用是安全的，因为当引用对象变为垃圾时，对其的任何弱引用都会失效，而不是允许其保持悬空状态，这意味着它变成了可预测的值，例如空引用。

Cocos2d-x中的所有对象几乎都继承自`Ref`基类，它的主要职责就是对对象进行引用计数管理，当用`new`运算符分配内存时，引用计数为1，调用`retain()`方法引用计数加1，调用`release()`方法则会使引用计数减1，当引用计数归零时`release()`方法会调用`delete`运算符删除对象并释放内存。同时，我们可以通过`autorelease()`方法声明一个指向对象的“智能指针”，这些指针会全部加入*AutoreleasePool*中，每一帧结束时会对pool中的对象进行清理，也就是说该指针的**生命周期**为从创建到当前帧结束。清理的机制是，*AutoreleasePool*对池中每个对象执行一次release操作，因此如果一个对象被创建，但它在这一帧从未被使用，那么执行该操作后会马上被释放。Ref的引用计数并不是线程安全的，在多线程中，我们需要通过处理互斥锁来保证线程的安全。

为了简化声明（先`new`再`autorelease()`），Cocos2d-x使用static方法`create()`来返回一个指针对象，大部分类都可以用这个方法创建。

这就解释了，在zt项目中，用UIManager的`getOrCreatePanel`方法创建的ui如果不马上调用`showToScene`方法的话，会下一帧就会被析构。
