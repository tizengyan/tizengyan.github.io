---
layout: post
title:  "C#基础（待完成）"
#date:   2019-03-06 12:12:54
categories: 基础知识
tags: C#
excerpt: 总结一下C#的一些基础知识
author: Tizeng
---

* content
{:toc}

岗位需要，查了一些C#的资料，记录在此，方便以后回忆和整理。

## 值类型和引用类型

值类型数据储存在栈中，只需要一段内存，而引用类型需要两段内存，第一段是**数据**储存在堆中，第二段是**引用**储存在栈中。对于应用类型的对象，它的所有数据都在堆中。

## 类的静态成员

和C++一样，C#中的静态成员独立于类的实例，在堆中会有一块专门的区域储存，对于所有类的实例而言，静态成员只有一个副本，因此所做的任何改动都会影响所有实例。访问时直接用类的名称加点运算符（.）。
即使没有实例，也可以访问静态成员。

非静态成员称为实例成员，**静态函数成员**不能访问实例成员，但可以访问其他静态成员。

常量数据不能被声明为静态的。但它的表现得和静态值一样，即使没有实例，依然可以访问。

### 静态构造函数

通常，静态构造函数初始化类的静态字段。与实例构造函数不同的是，类只能有一个静态构造函数，而且不能带参数，也不能有访问修饰符。同静态方法，静态构造函数不能访问类的实例成员，因此也不能使用`this`访问器。

我们也不能从程序中显式调用静态构造函数，下面两种情况时，系统会自动调用它们：

* 类的任何实例被创建之前

* 类的任何静态成员被引用之前

## 类的属性

这是C#中常用的一种写法。我们可以像操作字段一样操作属性，而本质上属性是一个**函数成员**，声明语法如下：

```c#
class C1{
    private int val; //后备字段
    public int myVal{
        set{
            val = value;
        }
        get{
            return val;
        }
    }
}
```

上面的代码声明了一个名为`myVal`的`int`型属性，其中set和get是被称为访问器的方法，set访问器有一个单独的隐式的值参，名为`value`，与属性的类型相同，返回类型为void。get访问器没有参数，返回类型与属性类型相同。

要注意的是属性本身并没有任何存储，由访问器决定如何处理发进来的数据。定义好后，我们就可以像访问普通字段一样访问或赋值这个属性了，属性会根据赋值还是读取，隐式的调用访问器。

为了方便理解，一般来说属性和其后备字段有几种命名约定，一种是字段使用Camel大小写（myVal），属性使用Pascal大小写（MyVal）；第二种与第一种类似，只是字段前面加一个下划线（_myVal）。

属性和字段一样可以被声明为`static`。

### 属性的优势

get访问器为只读属性，set访问器为只写，在定义属性时我们可以不定义某个访问器。因此属性可以只读或只写，而字段不行。

属性可以输入和输出，比如可以将set访问器中的代码改成`val = value > 100 ? 100 : value;`。

有一种常见的封装写法如下：

```c#
public string Name {get; private set;}
```

这样一来，在外部就只能读取该属性，而不可以设置。

有几点要注意：

* 两个访问器中只能有一个有访问修饰符

* 访问器的访问修饰符必须必成员的访问级别有更严格的限制性。比如如果一个属性的访问级别是public，那么访问器声明为任意一个非public级别，而如果属性的访问级别为protected，那么唯一能对访问器使用的修饰符就只有private了。

## this关键字

`this`只能被用在：实例构造函数、实例方法、属性和索引器的实例访问器中，它返回当前实例的引用。

## 索引器

索引器是一组get和set访问器，与属性类似，不用分配内存，不同的是，属性通常表示单独的数据成员，索引器通常表示多个数据成员。

使用索引器，还需注意以下几点：

* 索引器可以只有一个访问器，也可以两个都有

* 索引器总是实例成员，因此不能被声明为`static`

* 和属性一样，set和get访问器并不一定要关联某个字段

* 索引器没有名称，在名称的位置是关键字`this`

* 参数列表在方括号中间，且至少声明一个参数

下面看实例代码：

```c#
class C1{
    int temp0, temp1;
    public int this [int index]{
        get{
            return 0 == index ? temp0 : temp1;
        }
        set{
            if(0 == index)
                temp0 = value;
            else
                temp1 = value;
        }
    }
}
```

### 索引器重载

只要索引器的参数列表不同，类就可以有任意多个索引器。只是返回类型不同是不够的。

## 垃圾回收器（GC）

## 委托

以类的形式声明，像对象一样创建实例，一次性**依次**调用函数列表中的所有函数，不论是否重复

调用列表中如果函数有返回值只会返回最后一个函数的返回值

