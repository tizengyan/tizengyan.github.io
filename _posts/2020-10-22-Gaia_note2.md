---
layout: post
title: "Gaia笔记2——优化"
date: 2020-10-22
categories: 引擎
tags: ue4
excerpt: ue4中ui优化策略
author: Tizeng
---

* content
{:toc}

## 定制进度条

ue4居然只内置了普通的bar状进度条，如果需要其他形状的需要自己实现。

首先准备一张黑白的圆形渐变图（circular gradient），它从中心点到边缘的连线的灰度值一致，且按顺时针（或逆时针）从黑色（0）线性变化到白色（1）。接着在蓝图中实现一个根据输入percent来筛选alpha值的逻辑，小于输入为1，大于等于为0，就得到了一张扇形比特图遮罩，再用这张遮罩去multiply一张环形texture，就得到了该percent下的圆形进度条。

## 根据坐标求角度

贴一段引擎中定义的`Atan2`函数代码

```c++
float FGenericPlatformMath::Atan2(float Y, float X)
{
	//return atan2f(Y,X);
	// atan2f occasionally returns NaN with perfectly valid input (possibly due to a compiler or library bug).
	// We are replacing it with a minimax approximation with a max relative error of 7.15255737e-007 compared to the C library function.
	// On PC this has been measured to be 2x faster than the std C version.

	const float absX = FMath::Abs(X);
	const float absY = FMath::Abs(Y);
	const bool yAbsBigger = (absY > absX);
	float t0 = yAbsBigger ? absY : absX; // Max(absY, absX)
	float t1 = yAbsBigger ? absX : absY; // Min(absX, absY)
	
	if (t0 == 0.f)
		return 0.f;

	float t3 = t1 / t0;
	float t4 = t3 * t3;

	static const float c[7] = {
		+7.2128853633444123e-03f,
		-3.5059680836411644e-02f,
		+8.1675882859940430e-02f,
		-1.3374657325451267e-01f,
		+1.9856563505717162e-01f,
		-3.3324998579202170e-01f,
		+1.0f
	};

	t0 = c[0];
	t0 = t0 * t4 + c[1];
	t0 = t0 * t4 + c[2];
	t0 = t0 * t4 + c[3];
	t0 = t0 * t4 + c[4];
	t0 = t0 * t4 + c[5];
	t0 = t0 * t4 + c[6];
	t3 = t0 * t3;

	t3 = yAbsBigger ? (0.5f * PI) - t3 : t3;
	t3 = (X < 0.0f) ? PI - t3 : t3;
	t3 = (Y < 0.0f) ? -t3 : t3;

	return t3;
}
```

## Stack-Based FSM

前面和背包有关的UI框架搭的差不多了，现在有一个优化的任务，首先现在ui资源用的是散图生成的texture，希望出包的时候换成整图texture，节省空间降低draw call，其次是需要一个UIManager统一管理ui，目前显示ui和控制的逻辑基本都放在PlayerController里面，未来如果界面多起来会很冗余。

查ue4的ui管理的时候看到一个用栈状态机来优化的[文章](https://zhuanlan.zhihu.com/p/143882791)，感觉很合理，就查了一下这方面的资料。

FSM：有限状态机（Finite-State Machine），又叫有限自动机（finite-state automaton），一般来说分两种，确定有限状态机（deterministic finite-state machine）和非确定有限状态机（non-deterministic），这里确定指的是每次在特定条件输入时状态转移的唯一性，即对于所有输入都有且仅有一条transition，任意NFSM可以由DFSM所构建，反之亦然。

PDA：下推自动机（pushdown automaton），指的是操作一个栈的FSM

## 大厅技能、武器界面（2020.11.17）

比较基础的tab页签实现

根据数据加格子，点击格子显示选框，点击界面按钮对格子道具进行操作

服务器技能到底存效果id还是技能id，这个问题他妈一定要搞清楚

## 处决UI(2020.11.25)

杀死敌人之后充能，一定数量后激活处决技能，使用后清零。

场景中的NPC死亡之后通知玩家，然后计数。那么NPC死亡后如何通知？
现在是击杀NPC的数量成为一个属性，需要时去获取这个属性就得到数量，但是我们需要在这个属性变化时就得到通知，因此需要监听它的变化

如何判断该NPC是谁杀死的？

如何找到处决目标并下发事件？

## 连击计数(2020.12.7)

打中npc计入属性，监听属性变化，有变化时调用回调函数，更新ui

在连击状态的时候角色身上有tag和buff，需要用到AbilitySystemComponent
FGameplayEffectSpec来获取container
tag储存在定义好的FGameplayTagContainer中

连击时需要有一个倒计时的进度条表现，击中npc会回满，未命中会减少，这个效果通过定义一个timer，倒计时的总时间是知道的，因此在固定的时间间隔下就能计算出每次间隔需要减少的百分比，按这个百分比更新就行了。后面增加了一个需求，要求最后几秒钟有一个保护时间，并且这个时间所占的进度条比例可以配置。要实现这个需求就需要计算两段每次更新百分比，还是在同一个timer下更新。

未命中暂时通过比较新通知的百分比和之前储存的百分比来判断

客户端不能自己修改人物属性，要在服务器改，

在伤害计算时可以知道玩家击杀了某个npc，然后把分数加到相应属性上，但是手雷击杀、处决等不走常规伤害逻辑，这些情况的击杀如何加分？


## 结算（2020.12.16）

遇到GameOver触发器时触发结算，结算时需要显示自己和队友的数据

## Gameplay Ability System(GAS)

## Gameplay Effect

不同的buff，或被动技能

## 队友血条同步

GaiaChracterPlayer::Server_ReqTeamProperties

## 交互物品触发器框架

## 行为树

## 热更

## Bug合集

* go服务器收不到客户端发过去的消息请求，排查后发现是客户端请求的接口UFUNCTION带了Server标签
* 连击结束后播放几秒钟的结束动画显示此次连击的积分，若是此时再次触发连击，则连击UI在后面都不可见了，原因是隐藏UI的动画被新动画打断，而隐藏动画修改的可见性没有恢复，所以看不见了，只需在播放隐藏动画的时候设置一个标志位flag，只要flag为true就不播放其他动画，隐藏动画播放完毕后再检查需要播放哪些动画。
