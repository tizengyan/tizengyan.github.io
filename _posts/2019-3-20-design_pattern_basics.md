---
layout: post
title:  "设计模式基础（待完成）"
categories: 基础知识
tags: design_pattern
excerpt: 总结一下设计模式的基本概念和常用的一些设计模式
author: Tizeng
---

* content
{:toc}

面向对象有三大基本特征，分别是是**封装**、**继承**和**多态**。

## 耦合性和内聚性

**耦合性**描述软件中各模块相互联系的紧密程度，模块之间联系越紧，其耦合度越强，独立性越差。

* 耦合性分类(低—>高)：无耦合、消息耦合、数据耦合、标记耦合、控制耦合、公共耦合、内容耦合。

**内聚性**指的是模块内各个元素彼此联系的紧密程度，一个模块内的元素联系越紧密，它的内聚性就越高。

* 内聚性分类(低–>高)：偶然内聚、逻辑内聚、时间性内聚、程序内聚、通信内聚、顺序内聚、功能内聚。

设计软件时要尽量做到，高内聚低耦合，提高模块的独立性。

紧密耦合的系统在开发阶段有以下的缺点：

1. 一个模块的修改会产生涟漪效应，其他模块也需随之修改。
2. 由于模块之间的相依性，模块的组合会需要更多的精力及时间。
3. 由于一个模块有许多的相依模块，模块的可复用性低。

## 设计模式的六大原则

1. 单一职责原则（Single Responsibility Principle）

    意思是一个类只应该负责一个职责。如果一个类负责多个职责，在对其中一个职责做修改时，可能会导致其他的职责出现问题，造成不必要的麻烦。应该将各个功能拆分成不同的类，提高内聚性。

2. 开闭原则（Open Close Principle）

    意思是对扩展开放，对修改关闭。在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。当软件需要变化时，尽量通过**扩展**软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。

3. 里氏替换原则（Liskov Substitution Principle）

    此原则强调，任何基类出现的地方，都可以被子类替换，而软件的功能不受影响。即基类派生子类时，可以增加新的功能，但尽量不要重写或重载基类的（非抽象）方法。换句话说子类可以对基类进行扩展，但不能改变基类原有的功能。

4. 依赖倒转原则（Dependence Inversion Principle）

    此原则定义为，高层模块不应依赖低层模块，二者都应依赖接口，细节应该依赖抽象。

    举例来说，我们需要一个读者读书，如果设计成读者一个类，书一个类，然后读者对象调用书的对象来读，这就是一个不符合该原则的设计，因为若要修改需求让读者读杂志、报纸等，需要依次对读者（上层结构）进行修改，这样加大了出错的风险，原因是耦合度太高，读者直接与书进行了互动。正确的做法是定义一个接口“读物”，读者与读物互动，不论输入的是何种读物，读者都可以阅读，而我们需要什么读物，直接继承这个接口实现就行了，即读者和书、报纸等，都依赖接口，对读物的改变不会影响读者这个类。

5. 接口隔离原则（Interface Segregation Principle）

    这个原则说的是一个类不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。如果接口的设计过于臃肿，让继承它的类不得不实现不需要的方法，那么就需要对这个接口进行拆分。

6. 迪米特法则，又称知识最少原则（Demeter Principle/Least Knowledge Principle）

    一个对象应该对其他对象保持最小的了解。类与类的关系越密切，耦合度就越大，我们应始终降低类与类之间的耦合。

补充一个合成复用原则（Composite Reuse Principle），这个原则让我们尽量使用合成/组合/聚合，少用继承。通过继承来复用的主要问题是会破坏类的封装，将基类的实现暴露给子类，如果基类发生改变，子类也必定会改变。如果新对象的某些功能在别的已经创建好的对象里面已经实现，那么尽量使用别的对象提供的功能，使之成为新对象的一部分，而不要自己再重新创建，这是降低耦合性的一种手段。

## 常见设计模式介绍

### 1.单例模式

1. 单例模式的类始终只能生成一个实例

2. 单例类必须自己创建这个唯一的实例

3. 单例类必须给其他对象提供这个唯一的类

我们可以将构造函数设置为私有，

### 2.享元模式

### 3.观察者模式

### 4.工厂模式

### 5.策略模式

### 6.状态模式

### 7.组建模式