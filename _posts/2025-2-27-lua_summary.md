---
layout: post
title: "Lua实现总结"
date: 2025-02-27
categories: Lua
excerpt: 尽量简洁的总结一下Lua各个特性的实现方式
author: Tizeng
---

复习lua实现的时候才发现之前写了不少东西，但也许之前看的太快，到最后变成了搬运帖子或书上的内容，没有真正学进去，工作的几年也疏于复习，导致现在基本得重新看，好像一下又回到了刚毕业找工作的那个夏天，感叹时间为什么不能多一些，让面试能更有把握。

悟已往之不谏，知来者之可追。

主要依据[构建lua解释器]（https://zhuanlan.zhihu.com/p/49972755）系列文章，尽量以总结的形式，少放代码。

## 函数调用

通过栈进行，之前一直没理解这个栈是如何构建的，其实是`lua_State`和`global_State`初始化的时候预分配了空间，然后储存了那个内存开头的地址作为`StkId stack`，使用加减就能移动到想去的内存片段中，分配时会多分配20个位置的空间，用来在元素超出时有一个缓冲，不至于崩溃。lua_State内部有一个`CallInfo`链表，储存函数调用信息，每次有函数调用时会创建一个新节点加进去，调用结束后被释放，然后执行下一个ci节点。

## Table

`Table`结构中分别缓存了一个数组一个哈希表，有一个`lsizenode`变量用来表示哈希表的大小，但真正的大小是2的`lsizenode`次方，这么做的目的是在取余的时候可以用位运算提高效率，而且哈希表的扩容也是成倍的，虚幻中哈希表在映射的时候也用了同样的方法。哈希表实际上也是一个数组，每个`Node`中除了有key和value之外，还有下个元素的下标，来达到链接的目的，这点也和虚幻中的很多实现一样。

* 查找：当key为int类型，先看看是否在数组范围内，如果是则直接返回数组对应位置的元素，如果不是则直接将其映射到哈希表中（对size取余），从表头开始依次比较是否找到了对应的key，找到了返回其值，没找到返回`luaO_nilobject`。如果key的类型不是int，则先计算哈希值然后进行后面的操作。

`Table`中还有一个`lastfree`成员，指向哈希表中最后一个空节点的位置，在增加新元素时用来寻找下一个空节点的位置。

* 写入：同样如果key是int类型则先看看在不在数组范围内，如果在就直接写，如果不在就走哈希表。定位到哈希表位置后，如果发生冲突，要先判断一下该位置已有的元素是否是属于这个节点的，因为当冲突发生时会通过lastfree找到一个有效位置将数据放进来，但找到的节点可能对应的是另一个key算出来的哈希值，也就是说它占了一个其他桶的位置，这时就需要先把这个元素移走，然后将新数据放进来。

哈希表会在增加或删除元素的时候进行resize，它的方式是先统计所有int类型的key，看看在每个2<sup>i - 1</sup>至2<sup>i</sup>（i = 0 ~ 32）区间内的数量，然后从i为0的情况开始累加，计算出一个尽可能大的，占用率超过百分之五十的数组大小，为新的数组大小，剩下的不能放进数组中的元素，则是新的哈希表大小（这里有点疑问，如果直接按这个大小那哈希表上来就是满的，下次如果发生哈希冲突又要重新散列？）

## userdata

用户自定的类型都会以userdata存储

## GC

和虚幻一样，使用的是标记清除法。
