---
layout: post
title: "Gaia笔记4——周版本更新"
date: 2021-1-27
categories: UE4
tags: gaia
excerpt: 版本更新新功能时遇到的问题
author: Tizeng
published: false
---

* content
{:toc}

## TWeakObjectPtr

## GC

之前更换模型很多次之后出现的内存暴涨4G的问题再次出现，尽管已经将更换Mesh改成了Destroy场景中的Actor再读表重新创建，怀疑是多次操作后积累了过多需要gc的资源，导致一次清理时消耗过多内存。

## 系统提示信息（2021.1.28）

最开始我想根据三个枚举值去抽象每个提示消息，第一部分、第二部分、格式，c++把这三个类型通知到lua，然后lua去显示，做完交互的提示就发现这样设计很僵硬，如果提示所需的信息量不只三个，就需要重新定义通知的delegate，而这个不确定因素是不可控的，所以肯定不能这么做。在友哥的建议下先定义一个NoticeBase类，其中定义一个GenerateNoticeContent的接口，需要显示提示的地方根据需求使用相应的派生类

提示出现本该在自己客户端弹出的提示弹到了别人账号上的问题，原因是服务器用GetController得到的PC可能并不是客户端自己的PC，谁需要弹提示就要找到对应的PC去弹。 

## 设置界面（2021.2.4）

### 灵敏度等的设置条

UE4有Slider组件作为拖动条，更新和读取值十分方便，但表现很基础，策划需要跟随thumb显示的数字，要实现这个效果，得根据Slider长度和位置计算出thumb的初始位置，然后用其当前百分比算出一个当前位置，并把数字组件设到那个位置，而且每次SliderValue变化的时候都去更新。

有很多自适应的需求，在搭建小组件蓝图时（如可拖动进度条），过度使用Hbox和Overlay会影响自适应的效果，造成一些蛋疼的问题，有时候直接另加一个Canvas就完了。对于需要保持长宽比缩放的widget，可以考虑使用ScaleBox，然后设置合适的四周锚点，或者用其他容器包一下。

### 将界面接入灵敏度等设置

摄像机逻辑在GaiaCameraControlComponent中，先理一下触屏控制逻辑：首先在PlayerController（简称pc）的InputComponent上绑定（用BindTouch而非BindAction）了OnTouchMove等回调，例用pc的delegate通知lua处理，有触摸事件后会知道触摸的屏幕location，和此次点击最初的location比较过后，将变化的X值和Y值分别通知pc，pc负责用delegate广播yaw和pitch的变化，需要关心它们变化的component（比如这里的CameraControlComponent）会在BeginPlay时在pc的相应delegate上注册自己的回调函数（监听），然后处理逻辑。

### 镜头是如何转动的？

### TPS镜头跟随

* InputComponent是定义在Actor中的成员，Controller本身继承自Actor
* Character和Controller的关系？
* 多播（multicast）delegate指的是能绑定多个函数的delegate，在调用Broadcast后一并执行

### 储存玩家设置

使用引擎中自带的[SaveGame Object](https://docs.unrealengine.com/en-US/InteractiveExperiences/SaveGame/index.html)储存设置信息。

### 滑动条手感优化

ue4自带的Slider的功能很简单，只是一个可以拖动的条，点击其他位置会把thumb从当前位置设置到点击位置，但策划并不想要这样的效果

### 第一次打开设置界面的情况

此时会检测不到本地储存的SaveGameObj，直接创建一个，使用默认值初始化ui，然后储存该Obj。

### 与其他界面的冲突

设置界面打开时会隐藏hud，如果此时玩家死亡并且有复活机会，复活ui会与设置界面重叠，如果玩家复活，hud会因复活被打开，这是逻辑出现了冲突，打开设置界面隐藏了HUD，但死亡也会隐藏，然后复活时再打开，要解决这个问题只需要区分隐藏的层级，死亡时并不需要隐藏所有HUD，至少要留下退出按钮，因此只隐藏大部分HUD，而设置界面则隐藏所有HUD，包含死亡隐藏的部分，这样就不会有冲突了。

玩家死亡后可能会出现复活按钮，这部分逻辑原本在c++，现在要移到lua，相当于**c++通知lua**，在PC中定义一个delegate就行，后来发现直接加在死亡通知的delegate里面就行。

### 总结

这次做这个界面需要用很多通用组件，如显示数字的滑动条、多项选择条、确认界面等，遇到最多的问题是自适应，当外界大小变化时，有的组件要X方向同时变大，Y方向不变，而有的是部分变部分不变，还有的按比例变，需要活用canvas、scalebox和四角、两边锚点。

调数字位置时与Slider的Handle位置偶尔不能同步，MinValue越大不同步现象越明显，查看源码之后发现SliderValue在处理前减去了MinValue，我想当然的以为他不会去减，导致我计算出的百分比和Slider计算的不一致（能看源码还是好）。

做按下按钮持续增长减少时遇到按钮OnReleased事件不正常触发，是由于按钮勾选了IsFocusable导致。

滑动条右边mask是一串点点点的图片，直接设置size会使之变形，因此要把image的Tiling设置为horizontal，图片的锚点设在右端，AlignmentX设为1，这样可以在size变化时让其右端不动，从左边开始缩放，但Tiling默认是从左往右填充，没有方向的选项，会有不需要的移动效果，想让其从右往左填充，只需要将其ScaleX设为-1。

很多交互条件是以图片资源的大小为界限，做判断时应该直接去拿相应资源的大小，而不该去手动设置阈值，这样无论图片如何更换效果都保持一致。

widget有一个Clipping设置以前一直没有注意，直到这次发现ScrollBox会裁掉超出区域的ui而VerticalBox不会，查了一下之后才发现原来是可以设置的，ScrollBox默认超出边缘的child都会被裁掉。但其实并没有卵用，因为如果设置成不clip，那里面的内容就会超出ui区域。

lua修改灵敏度数值储存后，需要通知CameraControlComponent，实际上就是**lua通知c++**，在pc中定义一个delegate，注册回调，然后lua在需要时通知时Broadcast就行。

设置界面应该做成按配置去生成grid的形式，否则每次都要写相同的逻辑，之前没有直接这样做的原因一是时间紧来不及，二是美术需要看效果。

## 掉落物整合进交互（2021.3.15）

出现测试场景中没问题但进副本不触发问题，发现是掉落物actor在spawn时会有服务器和客户端区分，归属玩家的掉落由客户端生成，无归属的掉落由服务器生成然后同步给所有人。

掉落客户端表现

## 画质设置（2021.3.25）

## GM命令（2021.3.31）

游戏中按下`\``输入gm命令的实现很简单，只需要在CheatManager中加上对应的方法，输入与方法名一样的名称与参数就会执行，策划另外要求了一套GM面板，点击按钮后会在专门的界面上自动输入对应的gm命令，点击执行后激活功能，这就要求我们自己解析输进去的字符串，并为其绑定函数，同时还要拿到参数，调用时一并传入，传入的方法是将所有参数放进一个table，然后调用函数时直接把这个table传进去。

## 合作信息提示（2021.4.26）

### 队友1保护了队友2

在僵尸死亡时先判断是否满足保护条件（如周围有玩家），如果有则拿到击杀者名字，然后对所有玩家广播信息。

### 倒地提示

倒地后通知所有人玩家倒地，并给未倒地玩家显示帮助倒地玩家信息。这里的重点就是如何区分自己是不是倒地玩家，通常来说需要通知所有人会使用多播RPC函数，这样所有客户端都能收到，然后比较传入的PC和本地的FirstController来判断是不是该玩家，从而弹不同的提示（xxx救了你/你救了xxx）。还有一个方法，在Player类中定义一个static delegate用来通知倒地的状态，然后BeginPlay的时候注册，如此一来这个delegate就独立于各角色存在，每次Broadcast的时候会通知当前所有角色（实例），因此可以直接比较this和传入的角色指针来判断倒地者、救起者、击杀者，最后调用Client函数为其客户端显示提示。

### 尸潮提示

尸潮由触发器触发，有一个专门的蓝图类，在其中的OnActive事件中显示提示就行了。重要的是显示提示的方法，之前有些提示是用在提示类中为每个子功能写一个专门生成提示信息的方法，需要改提示的时候就调用，然后显示，但这样就很冗余，相当于每次要新提示就要加新方法，比较好的做法是定义一个通用的生成字符串的方法，然后创建一个继承自这个类的蓝图，在蓝图中配置表里的id，然后编辑器中定义一个ClassRef的基类变量，需要哪个信息就选哪个类，然后调用通用的方法即可。

### 特殊僵尸出现提示

直接在npc蓝图上做。

### Hunter相关提示（2021.5.16）

这块内容很关键，涉及到行为树和蒙太奇，以及GA。

hunter抓人是个技能，由行为树释放，专门的GA文件处理技能逻辑，当NPC死亡时会停止行为树，也就是停止释放技能。GetAbilitySystemComponent可以在技能激活和停止时注册回调，记录当前所释放的技能指针（UGameplayAbility*）。当NPC死亡时，判断击杀者是不是玩家，然后尝试用Cast将当前所释放技能转成抓人的技能，如果成功则说明此时应该显示救人提示。

抓人这个技能是由行为树释放的，

怪不是拖到场景里的，是使用专门生成怪的蓝图生成的，提供怪和行为树蓝图，它会用SpawnAIFromClass方法来生成。

## 系统提示优化（2021.4.25）

之前系统提示写的很急，没怎么考虑扩展性和可读性，直接在代码里显式按id读表数据，令人头大。

友哥提供了一个以蓝图为基础的思路，定义Notice类时，将id作为一个成员变量，由外部配置，Generate方法直接用这个id去读表返回内容。为不同的功能派生该类的子类蓝图，在蓝图中配置，然后在需要的地方生成实例，调用Generate方法生成内容，显示提示。比如尸潮提示，尸潮通过触发器触发，触发后会调用OnActive接口函数，我们只需要在这里显示通知就行了，为了知道生成的是哪个类，还需要增加一个蓝图ref变量，然后选择Notice类，再将默认值设置成配置好的子类蓝图，这样生成的实例就可以按我们配置的数据Generate出提示内容，而生成的实现在类的定义中。

基于上面的思路，把交互提示也优化一下，以前三种交互物：弹药箱、医药包和手雷的交互已满提示是直接写在交互技能触发时所进行的逻辑判断中，这样很不优雅，每种类型的交互都有一个蓝图继承自TT_Interaction，里面处理自己的逻辑，交互技能的逻辑判断只需要知道这次交互成不成功，至于成功或失败后发生什么事情，在交互蓝图里面做就行了，这样可以一定程度上解耦交互过程和交互结束的代码。

蓝图重载基类的方法，其实是生成了另一个方法（一般以`K2_`开头），基类该方法执行的时候最后会检查是否实现了这个方法，如果是则调用。

交互已满提示优化后出现自己的提示跑到别人那里去的问题，原因是使用Controller调用显示通知在服务器执行，服务器用`GetFirstPlayerController`拿到的Controller是不确定的，要定义一个Custom Event，然后把Replicate设为Client，再执行显示通知逻辑。目前蓝图的函数还不支持设置Replicates。

## 队友描边（2021.4.29）

中间插的小功能，TA提供了显示角色描边的接口，只需要客户端判断一下是否是自己，然后调用就行。

如何区分队友呢？目前是拿Actor身上的`Role`成员变量来判断（文档[在这](https://docs.unrealengine.com/en-US/InteractiveExperiences/Networking/Actors/Roles/index.html)）它和`RemoveRole`本身是储存该Actor是否由当前引擎直接管理的枚举，如果为`ROLE_Authority`，`RemoteRole`为其他两种，则说明当前的引擎实例负责管理这个Actor并将其replicate到远端。但从客户端视角来看，Role其实是为ROLE_SimulatedProxy，而RemoteRole为ROLE_Authority，因为服务器才是该Actor的实际管理者，客户端只是收到了更新它的通知，并在本地让它尽量和服务器上的行为一致。服务器每次更新Actor信息可能会有间隔以节省带宽和CPU，如果客户端只是每次收到更新通知才去更新位置就会显得卡顿，因此在每次更新间隔中要做推断（extrapolating）。

`ROLE_SimulatedProxy`：标准的模拟方式，客户端在更新间隔中根据服务器通知的最新速度朝目标方向移动（队友）

`ROLE_AutonomousProxy`：被Controller持有（Possessed）的Actor所用模式，它代表该Actor在推断位置的过程中还需考虑控制器的输入（自己）

### 死亡后移除

如果队友角色死亡，需要移除描边，使用之前的濒死状态回调就行。

## 近战攻击（2021.5.12）

## 界面基类、继承、覆写方法

## Batch语法

`set /p VarName=`用来接收prompt输入，并将输入赋给变量。

## 多语言

## Bug合集

* 需要ContextObject的时候把this传入报cannot convert to 'UObject'的错，检查后发现该函数是const，因此this指针也是const，当然不能转了，改成GetWorld()就行了。
* 创建新类时即使有GENERATED_UCLASS_BODY也需要定义Constructor
* FString作为参数传入时记得加*
* 服务器调用一个BlueprintImplementableEvent无法通知到lua，要单独写一个Client函数
* 主干出现一个野指针问题，是我用来储存SaveGameObj的指针，没有用UPROPERTY，导致被gc
* 犯了个错误，把服务器没有开发完全的功能合进了主干，导致若干问题出现
