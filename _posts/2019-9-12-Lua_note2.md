---
layout: post
title:  "Lua学习笔记2"
#date:   2019-03-01 8:10:54
categories: 游戏开发
tags: Lua
excerpt: 继续学习Lua与C++的交互
author: Tizeng
---

* content
{:toc}

主要内容为教材《Lua程序设计（第4版）》第四部分：C语言API。

Lua是一种**嵌入式语言**，因为它能被当做库来扩展某个应用程序，同时使用了Lua的程序也可以在Lua环境中注册新的函数，从而增加一些无法直接用Lua编写的功能，因此Lua也是一种**可扩展的语言**。

以C语言为例，上述两种对Lua的定位分别对应了C和Lua的两种交互形式，第一种形式中（嵌入式语言），C拥有控制权，Lua被用作库，这种形式中的C被称为应用代码（application code）；第二种形式（可扩展语言）中，Lua拥有控制权，而C被用作库，此时C被称为库代码（library code）。应用代码和库代码都使用相同的API与Lua进行通信，这些API被称为C API。

## 虚拟栈

Lua和C的通信主要依靠的是栈，几乎所有的API调用都是在操作这个栈中的值，包括数据交换。

以Lua中的表为例，表的键和值可以是任意类型，那么如果我们用函数来定义一个表的赋值操作，就需要好几十种不同的函数，因为要考虑每种类型的组合，这样既不高效，还有可能误触发垃圾回收。因此Lua和C之间使用栈来交换数据，栈中的每个元素都能保存Lua中任意类型的值，当希望从Lua中获取一个值时，只需要将它压入栈中，而如果需要传值给Lua，首先将它压入栈，然后调用Lua将其弹出即可。这样就避免了将每种类型都去排列组合的麻烦。

其中的具体操作涉及到很多`lua_`开头的方法，它们是包含在`lua.h`中Lua提供的基础函数，后面有需要再具体整理。

## 独立解释器

用C++写一个简单的Lua解释器：

```c++
#include <iostream>
#include <string>
extern "C" {
#include "lua.h"
#include "lauxlib.h"
#include "lualib.h"
}
using namespace std;

int main() {
    int error;
    lua_State* L = luaL_newstate();
    luaL_openlibs(L);
    string input;

    while (cin) {
        cout << ">";
        getline(cin, input);
        error = luaL_loadstring(L, input.c_str()) || lua_pcall(L, 0, 0, 0);
        if (error) {
            cerr << lua_tostring(L, -1) << endl;
            lua_pop(L, 1);
        }
    }

    lua_close(L);
    return 0;
}
```

注意`extern "C"`这段是必须的，否则可能会出错，因为我们是C++项目，而头文件是用C写的。或者将其直接替换成`lua.hpp`。

运行这段代码，我们就可以在黑窗中正常的输入Lua语句并运行了，如果输入的语法有误，会有错误信息打印在屏幕上。

## 在C中调用Lua函数

首先在名为`test.lua`的文件中定义如下函数：

```lua
function myAdd(x, y)
    return x + y
end
```

然后将其至于主程序同一目录下，下面定义一个调用上面Lua函数的C++程序：

```cpp
#include <iostream>
#include <string>
#include <cstdarg>
#include "lua.hpp"

double myAdd(lua_State* L, double x, double y) {
    int isNum;
    double z;
    // 函数和参数入栈
    lua_getglobal(L, "myAdd");
    lua_pushnumber(L, x);
    lua_pushnumber(L, y);
    if (lua_pcall(L, 2, 1, 0) != LUA_OK) { // 两个传入参数和一个返回
        error(L, "error running function 'f': %s", lua_tostring(L, -1));
    }
    z = lua_tonumberx(L, -1, &isNum); // 取栈顶结果
    if (!isNum) {
        error(L, "function '%s' should return a number", lua_tostring(L, -1));
    }
    lua_pop(L, 1);
    return z;
}

int main() {
    lua_State* L = luaL_newstate();
    luaL_openlibs(L);
    string input;

    luaL_dofile(L, "test.lua"); // 读取Lua文件
    cout << myAdd(L, 2, 3) << endl;

    lua_close(L);
    return 0;
}
```

运行结果如下：

![img](https://github.com/tizengyan/images/raw/master/cpp_call_lua.png)

函数`lua_pcall`如果在运行中出错，会返回一个错误码，并在栈中压入一条错误信息，但如果有错误处理函数，在压入错误信息前，会先调用错误处理函数，我们可以通过`lua_pcall`的最后一个参数指定这个错误处理函数，0表示不提供，若传入非0参数，那么该参数应该是错误处理函数在栈中的索引，因此通常来讲错误处理函数应该被提前压入栈且位于待调用函数之下。另外，有两种情况`lua_pcall`不会调用错误处理函数，一是内存分配失败，二是消息处理函数（？）本身出错。

### 通用的调用函数

上面的例子只能针对`double`型的数值，如果要调用不同类型的参数还要定义另外的函数，显然不合理，因此还要定义一个可以处理任意类型的通用函数。

```cpp
void call_va(lua_State* L, const char* func, const char* typeIndicator, ...) {
    va_list vl;
    int argNum, resNum;

    va_start(vl, typeIndicator);
    lua_getglobal(L, func); // 函数入栈

    // 处理参数类型
    for (argNum = 0; *typeIndicator; argNum++) {
        luaL_checkstack(L, 1, "too many argument");
        switch (*typeIndicator++) { // 处理完一个参数类型后，将指针后移
            case 'd':
                lua_pushnumber(L, va_arg(vl, double));
                break;
            case 'i':
                lua_pushinteger(L, va_arg(vl, int));
                break;
            case 's':
                lua_pushstring(L, va_arg(vl, char*));
                break;
            case '>': // 参数类型处理完毕
                goto endargs;
            default:
                error(L, "invalid option (%c)", *(typeIndicator - 1));
        }
    }
    cout << "function in stack" << endl;
endargs:
    resNum = strlen(typeIndicator);
    if (lua_pcall(L, argNum, resNum, 0) != 0) {
        error(L, "error calling '%s': %s", func, lua_tostring(L, -1));
    }

    // 处理函数返回值类型
    resNum = -resNum; // 第一个结果的栈索引
    while (*typeIndicator) {
        switch (*typeIndicator++) { // 注意这里也要后移
            case 'd': {
                int isNum;
                double n = lua_tonumberx(L, resNum, &isNum); // resNum保证了得到相应顺序位置的返回值
                if (!isNum) {
                    error(L, "wrong result type");
                }
                //cout << n << endl;
                *va_arg(vl, double*) = n; // 修改传入的变量为返回结果
                break;
            }
            case 'i': {
                int isNum;
                int n = lua_tointegerx(L, resNum, &isNum);
                if (!isNum) {
                    error(L, "wrong result type");
                }
                *va_arg(vl, int*) = n;
                break;
            }
            case 's': {
                const char* s = lua_tostring(L, resNum);
                if (s == NULL) {
                    error(L, "wrong result type");
                }
                *va_arg(vl, const char**) = s;
                break;
            }
            default:
                error(L, "invalid option (%c)", *(typeIndicator - 1));
        }
        resNum++; // 将返回值变量索引后移
    }

    va_end(vl);
}
```

两个循环同时受变量`argNum`、`resNum`和`typeIndicator`长度的控制，`typeIndicator`是一个字符串，长度随输入参数和返回值的数量变化，格式形如`ddiis>id`，d、i、s分别代表浮点型、整型和字符串型，输入和返回值由`>`隔开，有几个输几个，具体调用格式如下：

```cpp
int main() {
    lua_State* L = luaL_newstate();
    luaL_openlibs(L);
    string input;

    luaL_dofile(L, "test.lua");
    cout << "general version: ";
    double z = -1;
    double x = 2, y = 3;
    call_va(L, "myAdd", "dd>d", x, y, &z);
    cout << z << endl;

    lua_close(L);
    return 0;
}
```

返回值我们现在外部定义好变量，然后以引用的方式传入，执行完毕后如果没有问题就会得到结果。

注意在调用时，输入和返回值的数量不光要与前面的`typeIndicator`长度相符，类型也一定要相符，否则可能会报错。

## 在Lua中调用C函数

当Lua调用C函数时，我们必须注册该函数，即以一种恰当的方式为Lua提供该C函数的地址。与上面C调用Lua函数类似，Lua调用C函数时，也使用了一个相同类型的栈，C函数从栈中获取参数，并将结果压入栈中。不同的是，此处的栈不是全局的，即每个函数都有其**私有的局部栈**。当Lua调用一个C函数时，第一个参数总是位于这个局部栈中索引为1的位置，不管这个行为何时发生，每次调用都只会看到本次调用自己的私有栈，其中索引为1的位置上就是第一个参数。

所有在Lua中注册是函数都必须使用一个相同的原型：

```cpp
typedef int (*lua_CFunction) (lua_State *L);
```

这里要注意返回值为整型，代表压入栈中的返回值的个数。在该函数返回后，Lua会自动保存返回值并清空栈。

### 方法1：将C函数嵌入应用程序

我们上面定义了一个简易的Lua解释器，我们可以在它的内部添加一个C函数，然后在读取用户输入之前，将这个函数注册，就能在Lua窗口中调用了。

```cpp
static int l_add(lua_State* L) {
    double x, y;
    //x = lua_tonumber(L, 1);
    //y = lua_tonumber(L, 2);
    x = luaL_checknumber(L, 1);
    y = luaL_checknumber(L, 2);
    lua_pushnumber(L, x + y);
    return 1;
}

int main() {
    int error;
    lua_State* L = luaL_newstate();
    luaL_openlibs(L);
    lua_register(L, "l_add", l_add); // 注册C函数
    string input;

    while (cin) {
        cout << ">";
        getline(cin, input);
        error = luaL_loadstring(L, input.c_str()) || lua_pcall(L, 0, 0, 0);
        if (error) {
            cerr << lua_tostring(L, -1) << endl;
            lua_pop(L, 1);
        }
    }
    lua_close(L);
    return 0;
}
```

![img](https://github.com/tizengyan/images/raw/master/lua_call_Cfunction.png)

### 方法2：导出C函数库（C模块）

我们同样可以将C函数所在源文件导出成动态（静态）库，然后在Lua文件中包含这个库，就可以调用其中的C函数了：

```cpp
extern "C" {
    static int add(lua_State* L) {
        double x, y;
        //x = lua_tonumber(L, 1);
        //y = lua_tonumber(L, 2);
        x = luaL_checknumber(L, 1);
        y = luaL_checknumber(L, 2);
        lua_pushnumber(L, x + y);
        return 1;
    }
}

static const struct luaL_Reg mylibs[] = {
    {"add", add},
    {NULL, NULL}
};

extern "C"  __declspec(dllexport) int luaopen_mylib(lua_State* L) {
    //luaL_newlibtable(L, mylibs);
    //luaL_setfuncs(L, mylibs, 0);
    luaL_newlib(L, mylibs);
    return 1;
}
```

定义的库函数格式前面已经说过了，下面两个一个是包含需要注册函数的数组，类型为`luaL_Reg`；和一个打开函数（主函数），用于读取前面定义的数组。注意两个函数定义时都要加上`extern "C"`关键词，因为我们是C++项目，主函数前面还要加上`__declspec(dllexport)`告诉Lua去读取它（[详见官网](https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2010/a90k134d(v=vs.100)?redirectedfrom=MSDN)）。

这个过程说来容易，实现的时候很多坑，在windows环境下要建立Lua开发环境，首先要将下载的源码导入到工作目录的`lua/include`文件夹中，然后我们需要编译Lua的动态链接库，将除`luac.c`和`lua.c`的所有源文件导入VS项目中，在项目属性->常规->配置属性中选择动态库（dll），然后将VS输出配置改为x64，点击生成解决方案，得到.dll和.lib两个库，并将它们移到`lua`文件夹待用。

下一步是编译Lua编译器，这时需要将源码中的`luac.c`文件加回来，然后选择导出类型为.exe，重新生成解决方案导出，得到编译器`luac.exe`，同样放在`lua`文件夹中。

最后编译Lua解释器，与之前不同的是，这次项目中只需要`lua.c`，其他的源文件都要移除，然后在项目设置中将`include`文件夹加入附加包含目录，并在链接器设置中也要加入`lua`目录使之包含刚刚生成的库文件，然后就可以导出解释器`lua.exe`了，同样把它放在`lua`中，就可以运行Lua代码了。

Lua环境搭好之后，用相同的方法导出上面的C++代码为dll文件，并放入`lua`文件夹，然后就可以包含我们导出的库并调用里面的函数了：

![img](https://github.com/tizengyan/images/raw/master/lua_call_Cfunction_dll.png)

## Debug日志

### (1) 编译时出现链接错误

出现形如

`LNK2019    无法解析的外部符号 _lua_close，该符号在函数 _main 中被引用  LuaCTest    D:\Projects\LuaCTest\LuaCTest\LuaCTest.obj  1`

的若干错误，应该是库没有链接上，而我编译Lua源码时用的[教程](http://lua-users.org/wiki/BuildingLuaInWindowsForNewbies)生成的是dll文件，也就是动态库，就算加入了VS的目录中也不能解决，因此后面又按照[网上的方法](https://blog.csdn.net/fengya1/article/details/53636774)重新建了一个解决方案生成静态库，然后在同一个解决方案下直接链接，就没问题。

后面再回头看那个动态库的版本，按照第二个教程将Lua源文件全部包含进VS项目之后就可以跑了。

### (2) VS断点无法进入（未加载pdb引发）

解决方法：在VS菜单栏依次进入调试->选项->常规，取消勾选要求源文件与原始版本完全匹配，然后重新生成解决方案。

### (3) dll库无法读取

.dll文件名也要和库名一致。

### (4) mutiple lua VMs detected

读取库后报这个错，查资料说是解释器和dll库没有全部动态链接导致，因此重新编译了Lua解释器和编译器，并确保导出dll时VS中的预处理器设置加入了`LUA_BUILD_AS_DLL`：

![img](https://github.com/tizengyan/images/raw/master/vs_dll_preprocessor.png)

这个错整了很久，查了很多解决方法都不行，无法确定到底是解释器导出有问题还是dll库导出有问题还是都有问题，之前Lua源码是按官网的一个教程用`build.cmd`文件编译的，没有用VS，所以干脆用VS全部编译重来一次。

这两天梯子都挂了，没有谷歌和YouTube，解决问题的效率变低了，最后还是用手机上的梯子查了YouTube视频解决的问题。

### (5) 导出解释器时始终失败

报“无法解析的外部命令”的链接错误，解决方法是将项目中的除`lua.c`的Lua源文件删除，然后在项目设置中将源文件的目录作为附加目录。
