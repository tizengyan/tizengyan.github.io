---
layout: post
title:  "Lua学习笔记3"
categories: 游戏开发
tags: Lua
excerpt: 学习一下lua中的协程和底层的实现原理
author: Tizeng
---

* content
{:toc}

## 协程（coroutine）

协程类似线程，有自己的局部变量，和其他协程共享全局变量，有自己的栈（？），和线程最主要的不同是程序会同时有多个线程在跑，但是协程不是，在任何时候都只能有一个协程在跑，而且它在被显式要求时才会被挂起。协程有三个状态：suspended、running、dead。关于协程的操作被封装在`coroutine`表中：

* 用create创建协程，它的参数是一个函数（一般为直接定义的匿名函数），返回一个thread类型
* resume开始或重启协程，参数为create出来的协程
* yield将协程挂起，等待下一次的resume
* 期间用status查看协程的状态，参数为create出来的协程

要注意的是resume会根据协程是否还能继续返回true或false，如果能继续执行则true后面还会返回yield中输入的参数。resume的参数会传递给用create创建的coroutine函数中，yield会返回其额外的参数。当协程结束时，其返回的值（如果有）也会变成resume的返回值。

```lua
local co = coroutine.create(function(i)
    print(coroutine.yield("yield args1", i, 1))
    print(i)
    print(coroutine.yield("yield args2", i, 2), "in yield 2")
    return "a", "b"
end)
print("1-----:", coroutine.resume(co, 4))
print("========")
print("2-----:", coroutine.resume(co, 10, 2, 3))
print("========")
print("3-----:", coroutine.resume(co, 5, 6, 7))

--[[ 输出
1-----:	true	yield args1	4	1
========
10	2	3
4
2-----:	true	yield args2	4	2
========
5	in yield 2
3-----:	true	a	b
]]
```

协程最常见的一个应用便是解决生产者-消费者问题（producer-consumer problem），我们将发送端（producer）定义成一个协程，当接收端（consumer）需要信息的时候，便resume这个协程，它经过若干处理后返回要发送的值，并将协程挂起，等待下一次请求，这种设计只在我们需要的时候才去调用producer，因此也称为消费者驱动（consumer-driven），下面是一个简单的实现，来自[lua官网](https://www.lua.org/pil/9.2.html)：

```lua
function send(x)
    coroutine.yield(x)
end

local producer = coroutine.create(
    function()
        while true do 
            local x = io.read()
            send(x)
        end
    end)

function receive()
    local status, value = coroutine.resume(producer)
    return value
end

print(receive())
```

可以进一步对上面的结构进行扩展，增加一个filter处理数据，send和receive方法不变，将producer改为函数：

```lua
function receive (prod)
    local status, value = coroutine.resume(prod)
    return value
end

function producer()
    return coroutine.create(function()
        while true do 
            local x = io.read()
            send(x)
        end
    end)
end

function filter(prod)
    return coroutine.create(function()
        line = 1
        while true do 
            local x = receive(prod)
            x = string.format("%5d %s", line, x)
            send(x)
            line = line + 1
        end
    end)
end

function consumer(prod)
    while true do 
        local x = receive(prod)
        io.write(x, "\n")
    end
end

p = producer()
f = filter(p)
consumer(f)
--consumer(filter(producer()))
```

协程还有一种作为迭代器的用法，就是在循环的时候每次通过yield来结束本次迭代，比如在一个递归函数中：

```lua
function func2(a, n)
    if n == 0 then 
        -- xxx
        coroutine.yield(xxx)
    else
        -- ...
        func2(a, n - 1)
        -- ...
    end
end

function func1(a)
    local n = table.getn(a)
    local co = coroutine.create(function() func2(a, n) end)
    return function() -- iterator
        local code, res = coroutine.resume(co)
        return res
    end
end

-- 可以用wrap来代替上面的写法，它们是等价的
function func3(a)
    local n = table.getn(a)
    return coroutine.wrap(function() func2(a, n) end)
end

for p in func3{"a", "b", "c"} do 
    print(p) -- 这里的p就是func2里面返回的xxx
end
```

## lua原理

这里的主要依据为codedump写的《Lua设计与实现》。

```c++
#define CommonHeader GCObject *next; lu_byte tt; lu_byte marked 
// tt为数据类型，marked为GC相关标记位

typedef struct GCheader{
    CommonHeader;
} GCheader;

union GCObject{
    GCheader gch;
    union TString ts;
    //...
}

typedef union {
    GCObject *gc;
    void *p;
    lua_Number n;
    int b;
} Value;

#define TValuefields Value value; int tt
// tt为数据的类型

typedef struct lua_TValue {
    TValuefields;
} TValue;
// TValue可以表示lua中任何数据
```

任何需要GC的lua数据类型，必然以`CommonHeader`作为该结构体定义的最开始部分。

然而还有一些数据类型是不需要GC的，lua将GCObject和它们一起放在了联合体`Value`中。

## 字符串

字符串在lua中是不可被改变的数据，多份相同的字符串只有一个副本，称为内化，在lua虚拟机中用一个散列桶存放当前所有字符串，如果一个字符串没有在任何地方引用，将在GC阶段被回收。传统的字符串比较算法根据字符串的长度逐位进行对比，其时间复杂度与字符串的长度线性相关，内化之后就只需要计算字符串的散列值了。变量存放的仅是字符串的引用。

因此为了提高效率，应该尽量少的使用`..`来连接字符串，如果需要大量连接的操作，可以先将要连接的字符缓存在一个表中，然后用`table.cancat()`方法连接。

## 表

lua中表分为数组和散列表两个部分，任何数组不能储存的数据都会储存在散列表中，只要键值不为`nil`。

```c++
typedef union TKey {
    struct {
        TValuefields;
        struct Node *next;
    } nk;
    TValue tvk;
} TKey;

typedef struct Node {
    TValue i_val;
    TKey i_key;
} Node;

typedef struct Table{
    CommonHeader;
    lu_byte flags;
    lu_byte lsizenode;          // 以2为底的散列表大小对数值
    struct Table *metatable;    // 元表
    TValue *array;              // 数组部分
    Node *node;                 // 散列桶数组起始位置
    Node *lastfree;             // 散列桶数组最后位置
    GCObject *gclist;
    int sizearray;              // 数组大小
}
```

`Node`是散列桶的节点类型，其中的值是前面定义的通用数据类型`TValue`，键会根据需要决定是否使用链表。在查找时，如果输入的key是一个正整数且小于数组的大小，那么会尝试在数组部分查找，否则尝试在散列表部分查找。

散列表用链表解决冲突，将hash相同的元素储存在一个链表中，查找时先计算元素的hash，然后在遍历对应链表的所有元素。为了以最大效率储存数据，lua用一个数组`nums`的第i个元素记录key在2^(i - 1)到2^i之间的元素数量，如果数组在每一个2次方位置容纳的元素数量都超过该范围的50%，我们就认为这个数组范围发挥了最大的效率。只有三个元素的表在依次添加时会执行三次重新散列的操作，而100万个元素的表只需要20次，因此如果我们需要很多长度很小的表，可以在创建时预先填充元素避免重新散列。

表的取长度操作符`#`会优先取数组部分的长度，且在数组key不连续（元素存在空洞）时可能指向任何一个`nil`值位置前一个位置的下标。
