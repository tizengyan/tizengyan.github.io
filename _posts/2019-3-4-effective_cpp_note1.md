---
layout: post
title:  "《Effective C++》笔记——面向对象套路（待完成）"
date:   2019-03-04 21:22:54
categories: C++
tags: OOP
excerpt: C++面向对象的一些技巧
author: Tizeng
---

* content
{:toc}

《Effective C++》读书笔记。

## 确定对象被使用前已经被初始化（条款4）

在不同语境中如果我们在声明变量但不主动初始化时，如`int x;`，它有可能是0，也有可能是其他值，这会导致“不明确的行为”，甚至因为无法读取而让程序终止运行。

分清赋值和初始化，一个类中的成员变量可以在构造函数中初始化，但是如果在类的定义中只是声明了它们，然后在构造函数的实现中对其进行赋值，虽然可以达到一样的效果，但是这是赋值而非初始化（伪初始化），因为实际上它们的初始化时间发生的更早，是在这些成员的default构造函数被自动调用之时。

最好的方法就是使用构造函数的**初始化列表**来对每个成员初始化。注意用该列表时成员的初始化顺序只和它们的声明顺序有关，因此为了避免由次序初始化带来的bug，在列表中最好总是以声明次序为次序。

还有一个问题是C++对“定义于不同编译单元内的non-local static对象”的初始化次序没有明确定义。non-local static对象指的是声明在函数外的任何static对象，也就是说如果某个类的初始化依赖于一个外部类的静态实例（如以extern关键词定义，extern与static声明的变量的生命周期相同），我们无法保证该变量的初始化在这个类之前。为了解决这个问题，可以将non-local static对象搬进一个函数中，让其变成local static对象，这样我们就知道它什么时候会初始化了，即在调用该函数时。

```c++
class FileSystem {...};
FileSystem& tfs(){
    static FileSystem fs;
    return fs;
}

class Dir {...};
Dir& tempDir(){
    static Dir td;
    return td;
}
```

如此一来我们得到的就是指向static对象的引用，而不是对象自身了。

## （条款12）

## （条款30）

## 为多态基类声明virtual析构函数（条款07）

想象一个简单的情况，当一个子类对象经由一个基类指针被删除，比如：

```c++
class Clock{
public:
    Clock();
    ~Clock();
    ...
};

class AtomicClock : public Clock{...};

int main(){
    Clock* clock = new AtomicClock();
    ...
    delete clock;
    return 0;
}
```

这会导致`AtomicClock`中的成分没有被销毁，而`Clock`中的成分被销毁了，造成一种局部销毁的窘境，从而引发资源泄露。解决这个问题的方法很简单，即给基类声明一个`virtual`**析构函数**，这样一来就不会出现销毁不全的情况了。

任何类中只要有`virtual`函数几乎确定应该也有一个`virtual`析构函数。如果一个类被设计成不需要派生任何基类，那么它则不应该带有任何虚函数，否则会徒增对象的体积。原因是一旦虚函数被声明，则必须携带一个指针`vptr`（virtual table pointer）用以在运行时决定哪个虚函数应该被调用，`vptr`指向一个由函数指针构成的数组，称为`vtbl`（virtual table），每个带有虚函数的类都有一个相应的`vtbl`，当虚函数被调用时，实际被调用的函数取决于`vptr`所指向的`vtbl`。

我们甚至可以将基类的析构函数声明为纯虚函数，这样我们就在不声明其他虚函数时得到了一个抽象类（不可被实例化），不过要注意的是一定要记得为这个纯虚析构函数提供一个定义。

析构函数的运作方式是，**最深层**的子类（most derived）的那个析构函数**最先**被调用，然后是其每个基类的析构函数被调用。而编译器会对子类的析构函数中创建一个基类析构函数的调用，这就是为什么我们如果有一个纯虚析构函数，必须为它提供定义的原因。

### 总结：

* 带多态性质的基类应该声明一个`virtual`析构函数。如果一个类带有任何虚函数，则它就应该拥有一个`virtual`析构函数。

* 一个类如果不是为派生其他子类而设计，或不是为了具备多态性而设计，就不应该存在`virtual`函数。

## 区分接口继承和实现继承（条款34）

