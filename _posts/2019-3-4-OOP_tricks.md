---
layout: post
title:  "C++面向对象套路（待完成）"
date:   2019-03-04 21:22:54
categories: 基础知识
tags: OOP
excerpt: C++面向对象的一些技巧
author: Tizeng
---

* content
{:toc}

## 为多态基类声明virtual析构函数（条款07）

想象一个简单的情况，当一个子类对象经由一个基类指针被删除，比如：

```c++
class Clock{
public:
    Clock();
    ~Clock();
    ...
};

class AtomicClock : public Clock{...};

int main(){
    Clock* clock = new AtomicClock();
    ...
    delete clock;
    return 0;
}
```

这会导致`AtomicClock`中的成分没有被销毁，而`Clock`中的成分被销毁了，造成一种局部销毁的窘境，从而引发资源泄露。解决这个问题的方法很简单，即给基类声明一个`virtual`**析构函数**，这样一来就不会出现销毁不全的情况了。

任何类中只要有`virtual`函数几乎确定应该也有一个`virtual`析构函数。如果一个类被设计成不需要派生任何基类，那么它则不应该带有任何虚函数，否则会徒增对象的体积。原因是一旦虚函数被声明，则必须携带一个指针`vptr`（virtual table pointer）用以在运行时决定哪个虚函数应该被调用，`vptr`指向一个由函数指针构成的数组，称为`vtbl`（virtual table），每个带有虚函数的类都有一个相应的`vtbl`，当虚函数被调用时，实际被调用的函数取决于`vptr`所指向的`vtbl`。

我们甚至可以将基类的析构函数声明为纯虚函数，这样我们就在不声明其他虚函数时得到了一个抽象类（不可被实例化），不过要注意的是一定要记得为这个纯虚析构函数提供一个定义。

析构函数的运作方式是，**最深层**的子类（most derived）的那个析构函数**最先**被调用，然后是其每个基类的析构函数被调用。而编译器会对子类的析构函数中创建一个基类析构函数的调用，这就是为什么我们如果有一个纯虚析构函数，必须为它提供定义的原因。

### 总结：

* 带多态性质的基类应该声明一个`virtual`析构函数。如果一个类带有任何虚函数，则它就应该拥有一个`virtual`析构函数。

* 一个类如果不是为派生其他子类而设计，或不是为了具备多态性而设计，就不应该存在`virtual`函数。

## 确定对象被使用前已经被初始化（条款4）



## 区分接口继承和实现继承（条款34）

