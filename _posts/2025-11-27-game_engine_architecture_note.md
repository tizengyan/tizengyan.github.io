---
layout: post
title: "《游戏引擎架构》读书笔记"
date: 2025-11-27
categories: 
excerpt: 简单记录一下读这本书的一些心得
author: Tizeng
---

* content
{:toc}

本来没打算做笔记，感觉书上的东西都比较好懂，不想再搬运一次，但发现时间久了之前看的东西确实会没什么印象，还是做一下记录，尤其是对那些“哦原来是这样”的内容。

## 第5章-游戏支持系统

这一章讲了一些基本的子系统如何管理和初始化的问题。

### 内存对齐

有一节说到如果内存要按4字节对齐，则内存地址的最低有效位只能是0x0、0x4、0x8和0xC，写成二进制分别是0b0000、0b0100、0b1000、0b1100，即最后两位必须位0。
原因是只有这样这个数才是4的倍数，想一下确实是这样没错，因为要是4的倍数，则必须增加整数倍的0b0100，那么最后两位永远会是0。
那么为什么只需要4就行了呢？我们要对齐的是4个字节32位，4只有两位而已。答案是地址的单位是字节，而不是位，也就是说每个地址对应的门牌号下的数据就有1个字节8位，因此只要这个地址被4整除，则必定是按4字节对齐的。
还有一个隐含信息，若一个操作系统的指针大小是4字节，则这个系统可以分配的内存就是2的32次方字节，即4GB。
有所得，AI的确增加了不少学习效率。

要将地址对齐至所需的大小（必须是2的幂），先取出最低有效位LSB（least significant byte），方法是用一个mask掩码做一次与运算，这个掩码用需要对齐的字节数大小减去1即可得到。
然后就可以用需要对齐的字节数减去取出的LSB，就是地址需要补上的字节数。

### 内存池

在使用内存池时，会提前分配一些内存，使用一个freelist去保存池子里的空闲元素（之前看虚幻中一些容器的实现和lua源码时都有遇到），而我们需要指针指向这些元素来进行索引，但实际上，由于这些元素是空闲的，我们可以直接利用它们本身，储存下一个元素的索引来形成链表，只要这个链表的长度不超过每个元素大小所能表示的极限（如16位可以支持65536个元素）。
很聪明的做法。

## 第7章-游戏循环

介绍了游戏的基本循环逻辑，也就是常说的tick。
其中提到时钟变量的概念，计算机通过启动后cpu进行的周期数目，来计算过了多长的时间，cpu的运行速度越快，频率越高，一秒钟所经过的cpu周期数目就越多，我们可以用一个64位整数，来记录经过了多少周期，已知cpu的频率，就可以计算出时间。

浮点数只适合存储相对较短的持续时间，计算帧间隔时，是先用前后经过的64位时钟周期相减，再将结果转化为`float`。要知道精确的周期信息，应该使用int64。

多处理器下处理循环时，不同硬件的方式不一样，有的是多个大核（xbox360），有的则是一个大核+多个小核（ps3）。

多线程有两种形式：
* 任务模型：每个主要子系统运行于独立线程，动画、物理、渲染等
* 作业模型：将工作分割为多个细小、独立的作业（job），加入队列，交给闲置的处理器去处理，这样做的优点是可以减少处理器的空闲，但会增加信息通信成本

## 第10章-渲染

计算阴影时，有一个阴影贴图的技术，是事先在光源位置和方向渲染一张贴图，计算从光源出发，第一个被遮挡的距离，然后将这个距离储存在贴图坐标中，在最终计算像素颜色的时候，根据片段对应的世界坐标，比较该位置距光源的距离和对应贴图中储存深度的大小，如果比它大，则表示被遮挡。
由于只需要储存深度数据，通常使用一个24位或32位浮点数，达到比较精确的效果，而非传统的8位灰度。
很有意思的技术。

## 第11章-动画

引擎并不在意骨骼，只在意关节。

局部关节是相对直属父关节指定的，其变换结果是将以该关节为坐标系表示的点变换到父关节空间表示的点或矢量。

## 第14章-运行时游戏性系统

除了常见的面向对象，以对象为中心的架构，还有以属性为中心的架构，即所有游戏对象都是属性的集合，属性按类型被集中管理，可以存在数据库或表中，以游戏对象的唯一标识符作为索引。由此衍生出两种内存布局
* SoA（struct of array）：属性为中心的布局，只有很少数的struct，但其中包含了所有属性类型的数组，这样可以最大程度的增加内存的缓存命中率，因为相同类型的数据此时在内存中是连续存储的
* AoS（array of struct）：传统的布局，所有不同类型的属性都放在同一个struct中，由这个struct去构成数组
