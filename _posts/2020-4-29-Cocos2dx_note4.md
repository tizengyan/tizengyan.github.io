---
layout: post
title:  "Cocos2dx开发笔记4——读代码"
categories: 游戏开发
tags: Cocos2dx
excerpt: Climb some shit mountain
author: Tizeng
---

* content
{:toc}

此笔记以Mac系统为平台。

## lua与c++的互调

lua脚本中可以用形如`seal.SealUtilToLua:someFunc()`的语句来调用C++中的方法，原因是初始化时C++中使用了[tolua](https://www8.cs.umu.se/kurser/TDBD12/VT04/lab/lua/tolua++.html)绑定若干需要在lua层调用的方法，并且使用了嵌套层级来根据类型区分要绑定的方法。

## zt技能系统

### 选定目标
### 攻击检查
### 伤害结算

### 远程攻击反馈

角色攻击时如果是远程攻击，当弹道到达目标点时，C++会调用lua脚本`PopNumberManager`的`onMagicBoom`方法显示上漂数值，需要显示的数字根据attacker、target、skillid作为索引储存在一个表中，其中还存有当前的服务器时间，最后准备显示时，根据与服务器的时间戳比对，只显示与当前时间相同的数字，具体显示的方法在`cCharacterExt.cpp`中定义，由脚本`SceneNpc.lua`调用，最终在`GameScene.cpp`的`Update`方法中每帧更新要显示的数字（如果有）。

## zt任务系统

类似于很多其他rpg游戏，界面左侧会有一个任务列表，根据任务的优先级由上往下显示若干任务描述，点击后角色会开始自动寻路，如果是敌人则自动攻击，如果是NPC则开启对话，并在结束后（击杀敌人数量达到任务要求或完成对话）自动开始该任务的下一个流程，期间如果用户有移动输入，会打断寻路，这应该和寻路的逻辑有关。

用户直接点击NPC和点击任务标签的区别？

### 寻路

寻路实现在`GodConfig`脚本中，其中`goto`方法是通过`pathID`读取路线中NPC等配置，通过一系列的条件判断，最后在回调函数中调用`moveTo`方法开启寻路。注意如果在调用事件(addCallEvent)中使用了多于一个的事件，那除第一个事件的其他事件都要继续使用`add***Event`方法加入事件处理队列。
如果在副本中要先去pathID对应的一个坐标处，再调用一次`goto`或`moveTo`去最终的目标点。如果目标国家不是当前国家，就要跨国寻路，跨国寻路时要先寻路到*边境*，寻路接口在`TransportData`脚本中，如果返回为`true`则说明寻路成功，调用`gotoTransport`方法去到目标点（存疑)。如果目标点就在当前地图，当与目标点距离比期望值大时，调用主角脚本的`addMoveEvent`方法。
如果是同一个国家的不同地图，就要考虑地图之间传送点的问题，`TransportData`中的方法`findPath`就是搜索不同地图间的传送点，算法就是简单的广度优先搜索，得到从当前地图到达目标地图所需的最少*传送点*的列表，然后去列表中第一个传送点的位置，即递归的调用`goto`或`moveTo`，知道到达目标点位置。

主角脚本中有一个成员`mInputCommandQueue`用来储存输入的事件，然后每帧会被`processInput`方法处理，MoveEvent会被`on_MoveEvent`方法处理，最后调用的也是`god.moveTo`方法。

角色本身的移动逻辑是在自身脚本中的`moveTo`方法中实现，这个方法继承自`SceneNpc`脚本，最后调用的是c++中的`cCharacterExt.requestPath`方法，经过一系列传递后在CAStar.cpp中的`FindPath`方法实现寻路，实现是基本的A*寻路，用map作为开闭表记录搜索的节点，通过计算节点xy坐标的哈希值来索引。寻路完成后，路径会保存在成员`m_Path`中，然后每次查询下一个节点，就会把该节点储存到成员`m_PathPreNode`中，再用专门的方法去访问它的xy坐标。

### 镖车寻路

### 自动护送

### 任务栏

点击任务响应

## Cocos的内存回收机制

以下内容部分为《我所理解的Cocos2d-x》的读书笔记，部分为wiki词条的翻译。

Cocos2d-x没有使用C++11的智能指针来管理内存，原因有二，一是智能指针在性能上会有比较大的损失，shared_ptr为了保证线程安全，必须使用一定形式的互斥锁来保证所有线程访问时其引用计数正确，这对游戏这种实时性很高的程序而言是不可接受的；二是在显式的创建智能指针和引用的语法不够自然（我对这点存疑）。

引用计数：常用的垃圾回收方法，记录对象被引用的次数，被引用时计数加一，引用被销毁时计数减一，当计数为0时就认为这个对象可以被回收了。它的优点是可以尽快回收不被使用的对象，对CPU的负担较小。

基于追踪：最常用的垃圾回收方法，简单来说就是区分哪些对象已经可以被释放空间（deallocate），哪些是从某些根对象（root objects）可以被拿到的（reachable），通常是正在使用的对象，剩下的就是可以被收集的垃圾了。

引用计数之于追踪的优点是对象会在没有被引用时马上就被回收，不需要等到回收周期再回收，这在实时性和有限的内存下非常重要，引用计数实现起来也较为简单。但它相比较追踪策略有两个主要缺陷：

1. 频繁的更新是低效率的源头，而追踪法可以通过上下文切换（context switching）等方法极大的影响性能，收集垃圾的过程往往不频繁。其次，引用计数法对每个内存管理的对象都要预留储存计数的空间，而在追踪法中，这些信息被隐性（implicitly）的储存在指向对象的引用中；
2. 循环引用，即两个或以上的对象互相引用形成循环的话，因引用计数就永远不会归零了，对于这个问题可以用弱引用（weak reference）策略，让那些往回指的指针（backpointers）不计入引用计数，此外，弱引用是安全的，因为当引用对象变为垃圾时，对其的任何弱引用都会失效，而不是允许其保持悬空状态，这意味着它变成了可预测的值，例如空引用。

Cocos2d-x中的所有对象几乎都继承自`Ref`基类，它的主要职责就是对对象进行引用计数管理，当用`new`运算符分配内存时，引用计数为1，调用`retain()`方法引用计数加1，调用`release()`方法则会使引用计数减1，当引用计数归零时`release()`方法会调用`delete`运算符删除对象并释放内存。同时，我们可以通过`autorelease()`方法声明一个指向对象的“智能指针”，这些指针会全部加入*AutoreleasePool*中，每一帧结束时会对pool中的对象进行清理，也就是说该指针的**生命周期**为从创建到当前帧结束。清理的机制是，*AutoreleasePool*对池中每个对象执行一次release操作，因此如果一个对象被创建，但它在这一帧从未被使用，那么执行该操作后会马上被释放。Ref的引用计数并不是线程安全的，在多线程中，我们需要通过处理互斥锁来保证线程的安全。

为了简化声明（先`new`再`autorelease()`），Cocos2d-x使用static方法`create()`来返回一个指针对象，大部分类都可以用这个方法创建。

这就解释了，在zt项目中，用UIManager的`getOrCreatePanel`方法创建的ui如果不马上调用`showToScene`方法的话，会下一帧就会被析构。

## tableview、scrollview

先来看一下背包道具格子实现，zt中背包格子并没有使用tableview，而是直接用了scrollview，根据背包的布局一个个的创建格子`UIItemIconBg`，并把它们设置到正确的位置，然后根据背包数据去初始化有道具格子的表现。

再来看福利菜单页签，它由左边的列表和右边的若干界面组成，左边的列表使用了tableview，创建tableview实例后根据左边列表节点的预设大小初始化，经过其他常规初始化后将实例添加为节点的孩子节点，然后调用`registerScriptHandler`为tableview注册回调函数，一般来说有四个需要注册，被触摸的回调（cc.TABLECELL_TOUCHED)、tableview中cell的尺寸（cc.TABLECELL_SIZE_FOR_INDEX）、tableview某个位置的cell（cc.TABLECELL_AT_INDEX）、cell的数量（cc.NUMBER_OF_CELLS_IN_TABLEVIEW）。第一个很直观，就是点击回调，具体看要什么功能了，如果一行需要显示多个item每个item有单独的点击回调，就不需要定义这个回调，而对每个item单独设置。第二个和第四个比较好理解，尺寸一般不会变，回调的返回值可以直接写死，数量可以根据需要显示的item布局的高度来返回，因为滑动的每个cell就是单独的一行。第三个回调需要根据idx正确的返回cell的实例，由于tableview为了节省空间只会生成总量多于可视范围内若干数量的cell，实际上是通过这个方法来知道滑动时应该显示哪些cell，如果是第一次调用这个方法，则需要创建tableviewCell，然后将要显示在cell的ui界面加到它的孩子节点。

## 主界面技能轮盘

主要是旋转的操作，通过比较横纵坐标从点击起始点和后面移动点变化的差值，来决定是顺时针旋转还是逆时针旋转，还是回到起始点，旋转时如果玩家按住轮盘移动，轮盘会跟着手指同步移动，此时是用横纵坐标之和除以二来近似旋转角度，实时设置旋转角，松开手指后根据幅度将轮盘归位，这里使用了`rotateTo`方法，使轮盘根据输入的index转到指定位置。注意旋转的是轮盘九个技能icon的父节点，因此旋转后技能icon会偏移，要依次将它们朝相反反向旋转回正确的朝向。

## 小地图实现

ClippingNode是cocos中的一个用于裁剪节点的类，它继承自`Node`，使用时用`setStencil`方法设置裁剪的形状（或模块stencil），用`addChild`方法设置底图，这样玩家就能看到被裁剪成圆形的小地图。下一步是实时更新地图下的格子坐标，主角每次移动小地图下方的格子坐标都会实时更新，这是先拿到Director上的scheduler，然后用`scheduleScriptFunc`注册一个根据主角目前位置刷新格子坐标text的方法，每隔一小段时间就会自动调用这个方法更新显示的坐标。小地图的实例储存在主界面成员中，因此更新小地图表现的方法要通过主界面ui脚本调用。

裁减了地图还不够，小地图还应随玩家的移动而相应的移动，这个功能同样通过上面注册在scheduler中的方法实现，每隔一小段时间根据任务的位置信息修改小地图底图的锚点，然后将其设置在小地图边框的中心，在cocos2dx中改变节点的锚点并不会改变它显示的位置，却会改变它的坐标！因为锚点的位置变了，以前的坐标相当于就表示了不同的位置，例如如果将锚点朝左上角移动，那么如果保持坐标不变，节点会向相反方向也就是右下角移动相应的距离。改锚点而不直接改坐标的理由，我认为是从小地图的表现来说，主角的点必须永远在中心，如果要设置位置，那么主角往上走地图就要往下走，比较反直觉容易出错，直接用锚点表示主角当前在地图上的位置，然后总是把地图坐标设在小地图边框的中心，这样的实现其实是符合直觉的。

锚点坐标的大小被限制在0-1区间内，因此要得到是当前玩家位置相对于地图长（或宽）的比例，地图是由格子组成的，角色的坐标并不是格子坐标，而地图的宽度又是以格子为单位，因此中间涉及到一些计算格子坐标的步骤，还要根据地图两边可能的空隙进行缩放，刚开始看可能有点晕，但只要搞清楚我们最后要的是什么，代码就很好理解了。地图信息在`MinMap`配置文件中。总体看来这部分代码还算可以，只是有些api实现了重复的东西，阅读时容易造成混淆。

## 摄像机，九屏消息

Camera，nineScreen

### 小地图刷新npc位置

如果观察未裁剪的小地图，会发现上面npc代表的点会在玩家靠近时才显示，如果离开一定距离就不显示，这应该就是使用了九屏消息刷新npc与玩家的位置关系，避免不必要的开销。

## 菜单红点

## 地编

## 打图，读整图

本地编译的时候游戏中的图形资源是通过makefile从策划目录拉下来的

plist、pvr.ccz、TexturePacker

## 场景管理

场景切换，场景加载

## 热更

## tolua
